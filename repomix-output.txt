This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where content has been formatted for parsing in markdown style, content has been compressed (code blocks are separated by ⋮---- delimiter).

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been formatted for parsing in markdown style
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)

## Additional Info

# Directory Structure
```
.github/work/
knowledge/archive/
knowledge/categories/
knowledge/domain-knowledge/
knowledge/schemas/
knowledge/templates/
src/mastra/tools/config/
.env.example
.gitignore
fix.md
mastra.config.ts
openapi.json
package.json
README.md
src/mastra/agents/agentic.agent.ts
src/mastra/agents/analyst.agent.ts
src/mastra/agents/architect.agent.ts
src/mastra/agents/base.agent.ts
src/mastra/agents/codeDocumenter.agent.ts
src/mastra/agents/coder.agent.ts
src/mastra/agents/config/agentic.config.ts
src/mastra/agents/config/analyst.config.ts
src/mastra/agents/config/architect.config.ts
src/mastra/agents/config/codeDocumenter.config.ts
src/mastra/agents/config/coder.config.ts
src/mastra/agents/config/config.types.ts
src/mastra/agents/config/copywriter.config.ts
src/mastra/agents/config/dataManager.config.ts
src/mastra/agents/config/debugger.config.ts
src/mastra/agents/config/index.ts
src/mastra/agents/config/marketResearch.config.ts
src/mastra/agents/config/model.utils.ts
src/mastra/agents/config/provider.utils.ts
src/mastra/agents/config/research.config.ts
src/mastra/agents/config/rlTrainer.config.ts
src/mastra/agents/config/seoAgent.config.ts
src/mastra/agents/config/socialMedia.config.ts
src/mastra/agents/config/uiUxCoder.config.ts
src/mastra/agents/config/writer.config.ts
src/mastra/agents/copywriter.agent.ts
src/mastra/agents/dataManager.agent.ts
src/mastra/agents/debugger.agent.ts
src/mastra/agents/index.ts
src/mastra/agents/marketResearch.agent.ts
src/mastra/agents/research.agent.ts
src/mastra/agents/rlTrainer.agent.ts
src/mastra/agents/seoAgent.agent.ts
src/mastra/agents/socialMedia.agent.ts
src/mastra/agents/uiUxCoder.agent.ts
src/mastra/agents/writer.agent.ts
src/mastra/database/examples.ts
src/mastra/database/index.ts
src/mastra/database/vector-store.ts
src/mastra/hooks/index.ts
src/mastra/index.ts
src/mastra/services/exasearch.ts
src/mastra/services/hyperbrowser.ts
src/mastra/services/langchain.ts
src/mastra/services/langfuse.ts
src/mastra/services/langsmith.ts
src/mastra/tools/ai-sdk.ts
src/mastra/tools/arxiv.ts
src/mastra/tools/brave-search.ts
src/mastra/tools/calculator.ts
src/mastra/tools/contentTools.ts
src/mastra/tools/document-tools.ts
src/mastra/tools/document.ts
src/mastra/tools/e2b.ts
src/mastra/tools/exasearch.ts
src/mastra/tools/github.ts
src/mastra/tools/google-search.ts
src/mastra/tools/graphRag.ts
src/mastra/tools/hyper-functionCalls.ts
src/mastra/tools/index.ts
src/mastra/tools/llamaindex.ts
src/mastra/tools/llmchain.ts
src/mastra/tools/mcp.ts
src/mastra/tools/mcptools.ts
src/mastra/tools/memoryQueryTool.ts
src/mastra/tools/paginate.ts
src/mastra/tools/readwrite.ts
src/mastra/tools/rlFeedback.ts
src/mastra/tools/rlReward.ts
src/mastra/tools/tavily.ts
src/mastra/tools/types.ts
src/mastra/tools/utils.ts
src/mastra/tools/vectorquerytool.ts
src/mastra/tools/wikibase.ts
src/mastra/utils/index.ts
src/mastra/utils/memory-diagnostics.ts
src/mastra/utils/thread-manager.ts
src/mastra/voice/elevenlabs.ts
src/mastra/voice/googlevoice.ts
src/mastra/voice/index.ts
src/mastra/workflows/index.ts
src/mastra/workflows/Networks/agentNetwork.ts
src/mastra/workflows/Networks/knowledgeWorkMoE.network.ts
src/mastra/workflows/Networks/productLaunchNetwork.ts
tsconfig.json
```

# Files

## File: fix.md
````markdown
# Things to fix

## 1. Fix the error in the research step aka make sure to use @agentic/mastra

```plaintext
Agentic adapter for the Mastra AI Agent framework.

package: @agentic/mastra
exports: function createMastraTools
```

```ts
import 'dotenv/config'

import { createMastraTools } from '@agentic/mastra'
import { WeatherClient } from '@agentic/weather' // Use any of @agentic/* tools need to have agentic mastra adapter or you will get an error it was just updated to new version
import { openai } from '@ai-sdk/openai'  // Use ai-sdk/google instead of ai-sdk/openai
import { Agent } from '@mastra/core/agent'

async function main() {
  const weather = new WeatherClient()

  const weatherAgent = new Agent({
    name: 'Weather Agent',
    instructions: 'You are a helpful assistant. Be as concise as possible.',
    model: openai('gpt-4o-mini'),
    tools: createMastraTools(weather)
  })

  const res = await weatherAgent.generate(
    'What is the weather in San Francisco?'
  )
  console.log(res.text)
}

await main()
```

### List of agentic tools that are compatible with the new version of @agentic/mastra
- @agentic/weather

- @agentic/mastra
  - exports: function createMastraTools
- @agentic/langchain
  - exports: function createLangChainTools
- @agentic/llamaindex
  - exports: function createLlamaIndexTools
- @agentic/genkit
  - exports: function createGenKitTools
- @agentic/serper
  - exports: class SerperClient, namespace serper
  - env vars: SERPER_API_KEY
- @agentic/ai-sdk
  - exports: function createAiSdkTools
- @agentic/google-drive
  - exports: function createGoogleDriveTools
- @agentic/mcp
  - exports: function createMcpTools, class McpTools
- @agentic/notion
  - exports: class NotionClient, namespace notion
  - env vars: NOTION_API_KEY
- @agentic/tavily
  - exports: class TavilyClient, namespace tavily
  - env vars: TAVILY_API_KEY
- @agentic/wikipedia
  - exports: class WikipediaClient, namespace wikipedia
- @agentic/wikidata
  - exports: class WikidataClient, namespace wikidata
- @agentic/social-data
  - exports: class SocialDataClient, namespace socialdata
  - env vars: SOCIAL_DATA_API_KEY
- @agentic/reddit
  - exports: class RedditClient, namespace reddit
- @agentic/midjourney
  - exports: class MidjourneyClient, namespace midjourney
  - env vars: MIDJOURNEY_API_KEY
- @agentic/google-docs
  - exports: class GoogleDocsClient, namespace googleDocs
- @agentic/google-custom-search
  - exports: class GoogleCustomSearchClient, namespace googleCustomSearch
  - env vars: GOOGLE_API_KEY, GOOGLE_CSE_ID
- @agentic/firecrawler
  - exports: class FirecrawlerClient, namespace firecrawler
  - env vars: FIRECRAWLER_API_KEY
- @agentic/exa
  - exports: class ExaClient, namespace exa
  - env vars: EXA_API_KEY
- @agentic/e2b
  - exports: function e2b
  - env vars: E2B_API_KEY
- @agentic/brave-search
  - exports: class BraveSearchClient, namespace braveSearch
  - env vars: BRAVE_SEARCH_API_KEY
- @agentic/arxiv
  - exports: class ArxivClient, namespace arxiv
- @agentic/calculator
  - exports: function calculator

Error: Error: An error occurred while processing your request. Invalid value at 'tools.function_declarations[10].parameters.properties[1].value.properties[1].value.any_of[1].enum[0]' (TYPE_STRING), false
`
Error: Error: An error occurred while processing your request. Invalid value at 'tools.function_declarations[5].parameters.properties[1].value.properties[1].value.any_of[1].enum[0]' (TYPE_STRING), false

## 2. Fix the error in the research step aka make sure to use @agentic/mastra

```json

{
  "activePaths": {
    "research-step": {
      "status": "failed",
      "stepPath": [
        "research-step"
      ]
    }
  },
  "runId": "4a8f167e-bc95-41ba-8bde-566887c4033b",
  "timestamp": 1744314840600,
  "results": {
    "research-step": {
      "status": "failed",
      "error": "Invalid value at 'tools.function_declarations[10].parameters.properties[1].value.properties[1].value.any_of[1].enum[0]' (TYPE_STRING), false"
    }
  },
  "sanitizedOutput": "{\n  \"activePaths\": {\n    \"research-step\": {\n      \"status\": \"failed\",\n      \"stepPath\": [\n        \"research-step\"\n      ]\n    }\n  },\n  \"runId\": \"4a8f167e-bc95-41ba-8bde-566887c4033b\",\n  \"timestamp\": 1744314840600,\n  \"results\": {\n    \"research-step\": {\n      \"status\": \"failed\",\n      \"error\": \"Invalid value at 'tools.function_declarations[10].parameters.properties[1].value.properties[1].value.any_of[1].enum[0]' (TYPE_STRING), false\"\n    }\n  }\n}"
}
```

## 3. Fix the error in mastra/index.ts

when building got a lot of errors like this:

bunch of ANY errors, undefined, null, etc.
````

## File: openapi.json
````json
{"openapi":"3.1.0","info":{"title":"Mastra API","description":"Mastra API","version":"1.0.0"},"paths":{"/api":{"get":{"responses":{"200":{"description":"Success"}},"operationId":"getApi","tags":["system"],"parameters":[],"description":"Get API status"}},"/api/agents":{"get":{"responses":{"200":{"description":"List of all agents"}},"operationId":"getApiAgents","tags":["agents"],"parameters":[],"description":"Get all available agents"}},"/api/networks":{"get":{"responses":{"200":{"description":"List of all networks"}},"operationId":"getApiNetworks","tags":["networks"],"parameters":[],"description":"Get all available networks"}},"/api/networks/{networkId}":{"get":{"responses":{"200":{"description":"Network details"},"404":{"description":"Network not found"}},"operationId":"getApiNetworksByNetworkId","tags":["networks"],"parameters":[{"name":"networkId","in":"path","required":true,"schema":{"type":"string"}}],"description":"Get network by ID"}},"/api/networks/{networkId}/generate":{"post":{"responses":{"200":{"description":"Generated response"},"404":{"description":"Network not found"}},"operationId":"postApiNetworksByNetworkIdGenerate","tags":["networks"],"parameters":[{"name":"networkId","in":"path","required":true,"schema":{"type":"string"}}],"description":"Generate a response from a network","requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","properties":{"input":{"oneOf":[{"type":"string"},{"type":"array","items":{"type":"object"}}],"description":"Input for the network, can be a string or an array of CoreMessage objects"}},"required":["input"]}}}}}},"/api/networks/{networkId}/stream":{"post":{"responses":{"200":{"description":"Generated response"},"404":{"description":"Network not found"}},"operationId":"postApiNetworksByNetworkIdStream","tags":["networks"],"parameters":[{"name":"networkId","in":"path","required":true,"schema":{"type":"string"}}],"description":"Generate a response from a network","requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","properties":{"input":{"oneOf":[{"type":"string"},{"type":"array","items":{"type":"object"}}],"description":"Input for the network, can be a string or an array of CoreMessage objects"}},"required":["input"]}}}}}},"/api/agents/{agentId}":{"get":{"responses":{"200":{"description":"Agent details"},"404":{"description":"Agent not found"}},"operationId":"getApiAgentsByAgentId","tags":["agents"],"parameters":[{"name":"agentId","in":"path","required":true,"schema":{"type":"string"}}],"description":"Get agent by ID"}},"/api/agents/{agentId}/evals/ci":{"get":{"responses":{"200":{"description":"List of evals"}},"operationId":"getApiAgentsByAgentIdEvalsCi","tags":["agents"],"parameters":[{"name":"agentId","in":"path","required":true,"schema":{"type":"string"}}],"description":"Get CI evals by agent ID"}},"/api/agents/{agentId}/evals/live":{"get":{"responses":{"200":{"description":"List of evals"}},"operationId":"getApiAgentsByAgentIdEvalsLive","tags":["agents"],"parameters":[{"name":"agentId","in":"path","required":true,"schema":{"type":"string"}}],"description":"Get live evals by agent ID"}},"/api/agents/{agentId}/generate":{"post":{"responses":{"200":{"description":"Generated response"},"404":{"description":"Agent not found"}},"operationId":"postApiAgentsByAgentIdGenerate","tags":["agents"],"parameters":[{"name":"agentId","in":"path","required":true,"schema":{"type":"string"}}],"description":"Generate a response from an agent","requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","properties":{"messages":{"type":"array","items":{"type":"object"}},"threadId":{"type":"string"},"resourceId":{"type":"string","description":"The resource ID for the conversation"},"resourceid":{"type":"string","description":"The resource ID for the conversation (deprecated, use resourceId instead)","deprecated":true},"runId":{"type":"string"},"output":{"type":"object"}},"required":["messages"]}}}}}},"/api/agents/{agentId}/stream":{"post":{"responses":{"200":{"description":"Streamed response"},"404":{"description":"Agent not found"}},"operationId":"postApiAgentsByAgentIdStream","tags":["agents"],"parameters":[{"name":"agentId","in":"path","required":true,"schema":{"type":"string"}}],"description":"Stream a response from an agent","requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","properties":{"messages":{"type":"array","items":{"type":"object"}},"threadId":{"type":"string"},"resourceId":{"type":"string","description":"The resource ID for the conversation"},"resourceid":{"type":"string","description":"The resource ID for the conversation (deprecated, use resourceId instead)","deprecated":true},"runId":{"type":"string"},"output":{"type":"object"}},"required":["messages"]}}}}}},"/api/agents/{agentId}/instructions":{"post":{"responses":{"200":{"description":"Instructions updated successfully"},"403":{"description":"Not allowed in non-playground environment"},"404":{"description":"Agent not found"}},"operationId":"postApiAgentsByAgentIdInstructions","tags":["agents"],"parameters":[{"name":"agentId","in":"path","required":true,"schema":{"type":"string"}}],"description":"Update an agent's instructions","requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","properties":{"instructions":{"type":"string","description":"New instructions for the agent"}},"required":["instructions"]}}}}}},"/api/agents/{agentId}/instructions/enhance":{"post":{"responses":{"200":{"description":"Generated system prompt and analysis","content":{"application/json":{"schema":{"type":"object","properties":{"explanation":{"type":"string","description":"Detailed analysis of the instructions"},"new_prompt":{"type":"string","description":"The enhanced system prompt"}}}}}},"400":{"description":"Missing or invalid request parameters"},"404":{"description":"Agent not found"},"500":{"description":"Internal server error or model response parsing error"}},"operationId":"postApiAgentsByAgentIdInstructionsEnhance","tags":["agents"],"parameters":[{"name":"agentId","in":"path","required":true,"schema":{"type":"string"},"description":"ID of the agent whose model will be used for prompt generation"}],"description":"Generate an improved system prompt from instructions","requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","properties":{"instructions":{"type":"string","description":"Instructions to generate a system prompt from"},"comment":{"type":"string","description":"Optional comment for the enhanced prompt"}},"required":["instructions"]}}}}}},"/api/agents/{agentId}/speakers":{"get":{"responses":{"200":{"description":"List of available speakers","content":{"application/json":{"schema":{"type":"array","items":{"type":"object","description":"Speaker information depending on the voice provider","properties":{"voiceId":{"type":"string"}},"additionalProperties":true}}}}},"400":{"description":"Agent does not have voice capabilities"},"404":{"description":"Agent not found"}},"operationId":"getApiAgentsByAgentIdSpeakers","tags":["agents"],"parameters":[{"name":"agentId","in":"path","required":true,"schema":{"type":"string"}}],"description":"[DEPRECATED] Use /api/agents/:agentId/voice/speakers instead. Get available speakers for an agent"}},"/api/agents/{agentId}/voice/speakers":{"get":{"responses":{"200":{"description":"List of available speakers","content":{"application/json":{"schema":{"type":"array","items":{"type":"object","description":"Speaker information depending on the voice provider","properties":{"voiceId":{"type":"string"}},"additionalProperties":true}}}}},"400":{"description":"Agent does not have voice capabilities"},"404":{"description":"Agent not found"}},"operationId":"getApiAgentsByAgentIdVoiceSpeakers","tags":["agents"],"parameters":[{"name":"agentId","in":"path","required":true,"schema":{"type":"string"}}],"description":"Get available speakers for an agent"}},"/api/agents/{agentId}/speak":{"post":{"responses":{"200":{"description":"Audio stream","content":{"audio/mpeg":{"schema":{"format":"binary","description":"Audio stream containing the generated speech"}},"audio/*":{"schema":{"format":"binary","description":"Audio stream depending on the provider"}}}},"400":{"description":"Agent does not have voice capabilities or invalid request"},"404":{"description":"Agent not found"}},"operationId":"postApiAgentsByAgentIdSpeak","tags":["agents"],"parameters":[{"name":"agentId","in":"path","required":true,"schema":{"type":"string"}}],"description":"[DEPRECATED] Use /api/agents/:agentId/voice/speak instead. Convert text to speech using the agent's voice provider","requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","properties":{"text":{"type":"string","description":"Text to convert to speech"},"options":{"type":"object","description":"Provider-specific options for speech generation","properties":{"speaker":{"type":"string","description":"Speaker ID to use for speech generation"}},"additionalProperties":true}},"required":["text"]}}}}}},"/api/agents/{agentId}/voice/speak":{"post":{"responses":{"200":{"description":"Audio stream","content":{"audio/mpeg":{"schema":{"format":"binary","description":"Audio stream containing the generated speech"}},"audio/*":{"schema":{"format":"binary","description":"Audio stream depending on the provider"}}}},"400":{"description":"Agent does not have voice capabilities or invalid request"},"404":{"description":"Agent not found"}},"operationId":"postApiAgentsByAgentIdVoiceSpeak","tags":["agents"],"parameters":[{"name":"agentId","in":"path","required":true,"schema":{"type":"string"}}],"description":"Convert text to speech using the agent's voice provider","requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","properties":{"input":{"type":"string","description":"Text to convert to speech"},"options":{"type":"object","description":"Provider-specific options for speech generation","properties":{"speaker":{"type":"string","description":"Speaker ID to use for speech generation"},"options":{"type":"object","description":"Provider-specific options for speech generation","additionalProperties":true}},"additionalProperties":true}},"required":["text"]}}}}}},"/api/agents/{agentId}/listen":{"post":{"responses":{"200":{"description":"Transcription result","content":{"application/json":{"schema":{"type":"object","properties":{"text":{"type":"string","description":"Transcribed text"}}}}}},"400":{"description":"Agent does not have voice capabilities or invalid request"},"404":{"description":"Agent not found"}},"operationId":"postApiAgentsByAgentIdListen","tags":["agents"],"parameters":[{"name":"agentId","in":"path","required":true,"schema":{"type":"string"}}],"description":"[DEPRECATED] Use /api/agents/:agentId/voice/listen instead. Convert speech to text using the agent's voice provider. Additional provider-specific options can be passed as query parameters.","requestBody":{"required":true,"content":{"audio/mpeg":{"schema":{"format":"binary","description":"Audio data stream to transcribe (supports various formats depending on provider like mp3, wav, webm, flac)"}}}}}},"/api/agents/{agentId}/voice/listen":{"post":{"responses":{"200":{"description":"Transcription result","content":{"application/json":{"schema":{"type":"object","properties":{"text":{"type":"string","description":"Transcribed text"}}}}}},"400":{"description":"Agent does not have voice capabilities or invalid request"},"404":{"description":"Agent not found"}},"operationId":"postApiAgentsByAgentIdVoiceListen","tags":["agents"],"parameters":[{"name":"agentId","in":"path","required":true,"schema":{"type":"string"}}],"description":"Convert speech to text using the agent's voice provider. Additional provider-specific options can be passed as query parameters.","requestBody":{"required":true,"content":{"multipart/form-data":{"schema":{"type":"object","required":["audio"],"properties":{"audio":{"type":"string","format":"binary","description":"Audio data stream to transcribe (supports various formats depending on provider like mp3, wav, webm, flac)"},"options":{"type":"object","description":"Provider-specific options for speech-to-text","additionalProperties":true}}}}}}}},"/api/agents/{agentId}/tools/{toolId}/execute":{"post":{"responses":{"200":{"description":"Tool execution result"},"404":{"description":"Tool or agent not found"}},"operationId":"postApiAgentsByAgentIdToolsByToolIdExecute","tags":["agents"],"parameters":[{"name":"agentId","in":"path","required":true,"schema":{"type":"string"}},{"name":"toolId","in":"path","required":true,"schema":{"type":"string"}}],"description":"Execute a tool through an agent","requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","properties":{"data":{"type":"object"}},"required":["data"]}}}}}},"/api/memory/status":{"get":{"responses":{"200":{"description":"Memory status"}},"operationId":"getApiMemoryStatus","tags":["memory"],"parameters":[{"name":"agentId","in":"query","required":true,"schema":{"type":"string"}}],"description":"Get memory status"}},"/api/memory/threads":{"get":{"responses":{"200":{"description":"List of all threads"}},"operationId":"getApiMemoryThreads","tags":["memory"],"parameters":[{"name":"resourceid","in":"query","required":true,"schema":{"type":"string"}},{"name":"agentId","in":"query","required":true,"schema":{"type":"string"}}],"description":"Get all threads"},"post":{"responses":{"200":{"description":"Created thread"}},"operationId":"postApiMemoryThreads","tags":["memory"],"parameters":[{"name":"agentId","in":"query","required":true,"schema":{"type":"string"}}],"description":"Create a new thread","requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","properties":{"title":{"type":"string"},"metadata":{"type":"object"},"resourceid":{"type":"string"},"threadId":{"type":"string"}}}}}}}},"/api/memory/threads/{threadId}":{"get":{"responses":{"200":{"description":"Thread details"},"404":{"description":"Thread not found"}},"operationId":"getApiMemoryThreadsByThreadId","tags":["memory"],"parameters":[{"name":"threadId","in":"path","required":true,"schema":{"type":"string"}},{"name":"agentId","in":"query","required":true,"schema":{"type":"string"}}],"description":"Get thread by ID"},"patch":{"responses":{"200":{"description":"Updated thread"},"404":{"description":"Thread not found"}},"operationId":"patchApiMemoryThreadsByThreadId","tags":["memory"],"parameters":[{"name":"threadId","in":"path","required":true,"schema":{"type":"string"}},{"name":"agentId","in":"query","required":true,"schema":{"type":"string"}}],"description":"Update a thread","requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object"}}}}},"delete":{"responses":{"200":{"description":"Thread deleted"},"404":{"description":"Thread not found"}},"operationId":"deleteApiMemoryThreadsByThreadId","tags":["memory"],"parameters":[{"name":"threadId","in":"path","required":true,"schema":{"type":"string"}},{"name":"agentId","in":"query","required":true,"schema":{"type":"string"}}],"description":"Delete a thread"}},"/api/memory/threads/{threadId}/messages":{"get":{"responses":{"200":{"description":"List of messages"}},"operationId":"getApiMemoryThreadsByThreadIdMessages","tags":["memory"],"parameters":[{"name":"threadId","in":"path","required":true,"schema":{"type":"string"}},{"name":"agentId","in":"query","required":true,"schema":{"type":"string"}}],"description":"Get messages for a thread"}},"/api/memory/save-messages":{"post":{"responses":{"200":{"description":"Messages saved"}},"operationId":"postApiMemorySave-messages","tags":["memory"],"parameters":[{"name":"agentId","in":"query","required":true,"schema":{"type":"string"}}],"description":"Save messages","requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","properties":{"messages":{"type":"array","items":{"type":"object"}}},"required":["messages"]}}}}}},"/api/telemetry":{"get":{"responses":{"200":{"description":"List of all traces (paged)"}},"operationId":"getApiTelemetry","tags":["telemetry"],"parameters":[],"description":"Get all traces"},"post":{"responses":{"200":{"description":"Traces stored"}},"operationId":"postApiTelemetry","tags":["telemetry"],"parameters":[],"description":"Store telemetry"}},"/api/workflows":{"get":{"responses":{"200":{"description":"List of all workflows"}},"operationId":"getApiWorkflows","tags":["workflows"],"parameters":[],"description":"Get all workflows"}},"/api/workflows/{workflowId}":{"get":{"responses":{"200":{"description":"Workflow details"},"404":{"description":"Workflow not found"}},"operationId":"getApiWorkflowsByWorkflowId","tags":["workflows"],"parameters":[{"name":"workflowId","in":"path","required":true,"schema":{"type":"string"}}],"description":"Get workflow by ID"}},"/api/workflows/{workflowId}/runs":{"get":{"responses":{"200":{"description":"List of workflow runs from storage"}},"operationId":"getApiWorkflowsByWorkflowIdRuns","tags":["workflows"],"parameters":[{"name":"workflowId","in":"path","required":true,"schema":{"type":"string"}}],"description":"Get all runs for a workflow"}},"/api/workflows/{workflowId}/resume":{"post":{"responses":{},"operationId":"postApiWorkflowsByWorkflowIdResume","tags":["workflows"],"parameters":[{"name":"workflowId","in":"path","required":true,"schema":{"type":"string"}},{"name":"runId","in":"query","required":true,"schema":{"type":"string"}}],"description":"Resume a suspended workflow step","requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","properties":{"stepId":{"type":"string"},"context":{"type":"object"}}}}}}}},"/api/workflows/{workflowId}/resumeAsync":{"post":{"responses":{},"operationId":"postApiWorkflowsByWorkflowIdResumeAsync","tags":["workflows"],"parameters":[{"name":"workflowId","in":"path","required":true,"schema":{"type":"string"}},{"name":"runId","in":"query","required":true,"schema":{"type":"string"}}],"description":"@deprecated Use /api/workflows/:workflowId/resume-async instead","requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","properties":{"stepId":{"type":"string"},"context":{"type":"object"}}}}}}}},"/api/workflows/{workflowId}/resume-async":{"post":{"responses":{},"operationId":"postApiWorkflowsByWorkflowIdResume-async","tags":["workflows"],"parameters":[{"name":"workflowId","in":"path","required":true,"schema":{"type":"string"}},{"name":"runId","in":"query","required":true,"schema":{"type":"string"}}],"description":"Resume a suspended workflow step","requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","properties":{"stepId":{"type":"string"},"context":{"type":"object"}}}}}}}},"/api/workflows/{workflowId}/createRun":{"post":{"responses":{"200":{"description":"New workflow run created"}},"operationId":"postApiWorkflowsByWorkflowIdCreateRun","tags":["workflows"],"parameters":[{"name":"workflowId","in":"path","required":true,"schema":{"type":"string"}},{"name":"runId","in":"query","required":false,"schema":{"type":"string"}}],"description":"Create a new workflow run"}},"/api/workflows/{workflowId}/startAsync":{"post":{"responses":{"200":{"description":"Workflow execution result"},"404":{"description":"Workflow not found"}},"operationId":"postApiWorkflowsByWorkflowIdStartAsync","tags":["workflows"],"parameters":[{"name":"workflowId","in":"path","required":true,"schema":{"type":"string"}},{"name":"runId","in":"query","required":false,"schema":{"type":"string"}}],"description":"Execute/Start a workflow","requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","properties":{"input":{"type":"object"}}}}}}}},"/api/workflows/{workflowId}/start-async":{"post":{"responses":{"200":{"description":"Workflow execution result"},"404":{"description":"Workflow not found"}},"operationId":"postApiWorkflowsByWorkflowIdStart-async","tags":["workflows"],"parameters":[{"name":"workflowId","in":"path","required":true,"schema":{"type":"string"}},{"name":"runId","in":"query","required":false,"schema":{"type":"string"}}],"description":"@deprecated Use /api/workflows/:workflowId/start-async instead","requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","properties":{"input":{"type":"object"}}}}}}}},"/api/workflows/{workflowId}/start":{"post":{"responses":{"200":{"description":"Workflow run started"},"404":{"description":"Workflow not found"}},"operationId":"postApiWorkflowsByWorkflowIdStart","tags":["workflows"],"parameters":[{"name":"workflowId","in":"path","required":true,"schema":{"type":"string"}},{"name":"runId","in":"query","required":true,"schema":{"type":"string"}}],"description":"Create and start a new workflow run","requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","properties":{"input":{"type":"object"}}}}}}}},"/api/workflows/{workflowId}/watch":{"get":{"responses":{"200":{"description":"Workflow transitions in real-time"}},"operationId":"getApiWorkflowsByWorkflowIdWatch","tags":["workflows"],"parameters":[{"name":"workflowId","in":"path","required":true,"schema":{"type":"string"}},{"name":"runId","in":"query","required":false,"schema":{"type":"string"}}],"description":"Watch workflow transitions in real-time"}},"/api/logs":{"get":{"responses":{"200":{"description":"List of all logs"}},"operationId":"getApiLogs","tags":["logs"],"parameters":[{"name":"transportId","in":"query","required":true,"schema":{"type":"string"}}],"description":"Get all logs"}},"/api/logs/transports":{"get":{"responses":{"200":{"description":"List of all log transports"}},"operationId":"getApiLogsTransports","tags":["logs"],"parameters":[],"description":"List of all log transports"}},"/api/logs/{runId}":{"get":{"responses":{"200":{"description":"List of logs for run ID"}},"operationId":"getApiLogsByRunId","tags":["logs"],"parameters":[{"name":"runId","in":"path","required":true,"schema":{"type":"string"}},{"name":"transportId","in":"query","required":true,"schema":{"type":"string"}}],"description":"Get logs by run ID"}},"/api/tools":{"get":{"responses":{"200":{"description":"List of all tools"}},"operationId":"getApiTools","tags":["tools"],"parameters":[],"description":"Get all tools"}},"/api/tools/{toolId}":{"get":{"responses":{"200":{"description":"Tool details"},"404":{"description":"Tool not found"}},"operationId":"getApiToolsByToolId","tags":["tools"],"parameters":[{"name":"toolId","in":"path","required":true,"schema":{"type":"string"}}],"description":"Get tool by ID"}},"/api/tools/{toolId}/execute":{"post":{"responses":{"200":{"description":"Tool execution result"},"404":{"description":"Tool not found"}},"operationId":"postApiToolsByToolIdExecute","tags":["tools"],"parameters":[{"name":"toolId","in":"path","required":true,"schema":{"type":"string"}}],"description":"Execute a tool","requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","properties":{"data":{"type":"object"}},"required":["data"]}}}}}},"/api/vector/{vectorName}/upsert":{"post":{"responses":{"200":{"description":"Vectors upserted successfully"}},"operationId":"postApiVectorByVectorNameUpsert","tags":["vector"],"parameters":[{"name":"vectorName","in":"path","required":true,"schema":{"type":"string"}}],"description":"Upsert vectors into an index","requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","properties":{"indexName":{"type":"string"},"vectors":{"type":"array","items":{"type":"array","items":{"type":"number"}}},"metadata":{"type":"array","items":{"type":"object"}},"ids":{"type":"array","items":{"type":"string"}}},"required":["indexName","vectors"]}}}}}},"/api/vector/{vectorName}/create-index":{"post":{"responses":{"200":{"description":"Index created successfully"}},"operationId":"postApiVectorByVectorNameCreate-index","tags":["vector"],"parameters":[{"name":"vectorName","in":"path","required":true,"schema":{"type":"string"}}],"description":"Create a new vector index","requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","properties":{"indexName":{"type":"string"},"dimension":{"type":"number"},"metric":{"type":"string","enum":["cosine","euclidean","dotproduct"]}},"required":["indexName","dimension"]}}}}}},"/api/vector/{vectorName}/query":{"post":{"responses":{"200":{"description":"Query results"}},"operationId":"postApiVectorByVectorNameQuery","tags":["vector"],"parameters":[{"name":"vectorName","in":"path","required":true,"schema":{"type":"string"}}],"description":"Query vectors from an index","requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","properties":{"indexName":{"type":"string"},"queryVector":{"type":"array","items":{"type":"number"}},"topK":{"type":"number"},"filter":{"type":"object"},"includeVector":{"type":"boolean"}},"required":["indexName","queryVector"]}}}}}},"/api/vector/{vectorName}/indexes":{"get":{"responses":{"200":{"description":"List of indexes"}},"operationId":"getApiVectorByVectorNameIndexes","tags":["vector"],"parameters":[{"name":"vectorName","in":"path","required":true,"schema":{"type":"string"}}],"description":"List all indexes for a vector store"}},"/api/vector/{vectorName}/indexes/{indexName}":{"get":{"responses":{"200":{"description":"Index details"}},"operationId":"getApiVectorByVectorNameIndexesByIndexName","tags":["vector"],"parameters":[{"name":"vectorName","in":"path","required":true,"schema":{"type":"string"}},{"name":"indexName","in":"path","required":true,"schema":{"type":"string"}}],"description":"Get details about a specific index"},"delete":{"responses":{"200":{"description":"Index deleted successfully"}},"operationId":"deleteApiVectorByVectorNameIndexesByIndexName","tags":["vector"],"parameters":[{"name":"vectorName","in":"path","required":true,"schema":{"type":"string"}},{"name":"indexName","in":"path","required":true,"schema":{"type":"string"}}],"description":"Delete a specific index"}}},"components":{"schemas":{}}}
````

## File: src/mastra/database/examples.ts
````typescript
/**
 * Example usage of memory persistence in agents
 *
 * This file demonstrates how to use memory persistence to maintain context
 * across multiple interactions with the same user or topic.
 */
⋮----
import { randomUUID } from "crypto";
import { researchAgent, writerAgent } from "../agents";
import { threadManager } from "../utils";
⋮----
/**
 * Demonstrates how to use memory persistence in a conversation with proper thread management
 */
export async function memoryConversationExample()
⋮----
// Generate a consistent user ID (in a real app, this would be your actual user ID)
⋮----
// Get or create a thread for this user - ensures consistent thread ID
⋮----
// Use the consistent thread ID for all interactions
⋮----
// Follow-up message using the same thread ID
⋮----
// Simulate returning later - retrieve the same thread
⋮----
// Get the same thread for the returning user
⋮----
// The agent will have access to the previous conversation history
⋮----
/**
 * Demonstrates how memory can be shared between different agent types with consistent thread IDs
 */
export async function multiAgentMemoryExample()
⋮----
// Create a consistent thread for multi-agent workflow
⋮----
// First agent (Research) gathers information
⋮----
threadId: threadInfo.id, // Use the same thread ID for all agents
⋮----
// Second agent (Writer) uses the same memory context to continue the work
⋮----
threadId: threadInfo.id, // Same thread ID ensures memory continuity
⋮----
/**
 * Helper function to test if memory is correctly reading from the database
 *
 * @param threadId - Thread ID to debug
 * @param userId - User ID associated with the thread
 */
export async function debugMemoryReading(threadId: string, userId: string)
⋮----
// Direct memory verification via agent
⋮----
// Use explicit memory options to ensure reading happens
⋮----
lastMessages: 50, // Request a larger message history
⋮----
topK: 10, // Request more semantic matches
````

## File: src/mastra/hooks/index.ts
````typescript
// Define the AgentResponse type locally based on usage
interface AgentResponse {
  text?: string;
  object?: unknown; // Consider using a more specific type if the object structure is known
  error?: string;
  // Include other potential properties if needed based on the agent's actual response structure
}
⋮----
object?: unknown; // Consider using a more specific type if the object structure is known
⋮----
// Include other potential properties if needed based on the agent's actual response structure
⋮----
/**
 * Response hook configuration interface
 */
interface ResponseHookConfig {
  minResponseLength?: number;
  maxAttempts?: number;
  validateResponse?: (response: AgentResponse) => boolean;
}
⋮----
/**
 * Creates an onResponse hook for handling agent responses
 * @param config - Configuration options for the response hook
 */
export function createResponseHook(config: ResponseHookConfig =
⋮----
// Check if response is valid according to custom validation
⋮----
// Handle empty or invalid responses
⋮----
// Check response length if text is present
````

## File: src/mastra/services/hyperbrowser.ts
````typescript
import { connect } from "puppeteer-core";
import { Hyperbrowser } from "@hyperbrowser/sdk";
import dotenv from "dotenv";
⋮----
// Create a new page
⋮----
// Navigate to a website
````

## File: src/mastra/services/langsmith.ts
````typescript
/**
 * LangSmith integration service for Mastra AI.
 *
 * Provides tracing and evaluation capabilities for monitoring and
 * improving LLM interactions within Mastra agents.
 */
⋮----
import { Client as LangSmithClient } from "langsmith";
import { env } from "process";
import { v4 as uuidv4 } from "uuid";
⋮----
/**
 * Configuration options for LangSmith tracing
 */
export interface LangSmithConfig {
  /** API key for LangSmith access */
  apiKey?: string;
  /** LangSmith API endpoint URL */
  endpoint?: string;
  /** Project name for organizing traces */
  projectName?: string;
  /** Whether to enable tracing */
  enabled?: boolean;
}
⋮----
/** API key for LangSmith access */
⋮----
/** LangSmith API endpoint URL */
⋮----
/** Project name for organizing traces */
⋮----
/** Whether to enable tracing */
⋮----
/**
 * Global LangSmith client instance
 */
⋮----
/**
 * Configures LangSmith tracing for the application
 *
 * @param config - Configuration options for LangSmith
 * @returns The configured LangSmith client
 * @throws If LangSmith configuration fails due to missing API key
 */
export function configureLangSmithTracing(
  config?: LangSmithConfig
): LangSmithClient | null
⋮----
// Skip if explicitly disabled
⋮----
// Use existing client if available
⋮----
// Set environment variables that LangSmith SDK relies on
⋮----
// Create LangSmith client
⋮----
/**
 * Creates a new LangSmith run for tracking a specific operation
 *
 * @param name - Name of the operation to trace
 * @param tags - Optional tags for categorizing the run
 * @returns A Promise resolving to the run ID for tracking the operation, or a fallback UUID
 */
export async function createLangSmithRun(
  name: string,
  tags?: string[]
): Promise<string>
⋮----
// Fallback to generating a UUID if LangSmith is unavailable
⋮----
// Generate a UUID locally to use as the run ID
⋮----
// Attempt to create the run in LangSmith, potentially passing the generated ID
// Note: createRun might return void, so we don't rely on its return value for the ID.
⋮----
id: runId, // Pass the generated UUID as the run ID if supported
⋮----
inputs: {}, // Add required inputs property
⋮----
// Return the locally generated UUID
⋮----
return uuidv4(); // Fallback UUID on error
⋮----
/**
 * Tracks feedback for a specific operation in LangSmith
 *
 * @param runId - The ID of the run to attach feedback to
 * @param feedback - Feedback information (rating, comment, etc.)
 * @returns Boolean indicating success or failure
 */
export async function trackFeedback(
  runId: string,
  feedback: {
    score?: number;
    comment?: string;
    key?: string;
    value?: any;
  }
): Promise<boolean>
⋮----
// Initialize LangSmith on module import
````

## File: src/mastra/tools/ai-sdk.ts
````typescript
import {
  type AIFunctionLike,
  AIFunctionSet,
  asAgenticSchema,
  isZodSchema,
} from "@agentic/core";
import { jsonSchema, tool } from "ai";
⋮----
/**
 * Converts a set of Agentic stdlib AI functions to an object compatible with
 * the Vercel AI SDK's `tools` parameter.
 */
export function createAISDKTools(...aiFunctionLikeTools: AIFunctionLike[])
````

## File: src/mastra/tools/arxiv.ts
````typescript
import {
  aiFunction,
  AIFunctionsProvider,
  pruneEmpty,
  sanitizeSearchParams,
} from "@agentic/core";
import { XMLParser } from "fast-xml-parser";
import defaultKy, { type KyInstance } from "ky";
import { z } from "zod";
⋮----
import { castArray, getProp } from "./utils";
⋮----
export type ValueOf<T extends NonNullable<unknown>> = T[keyof T];
⋮----
export interface ArXivResponse {
    totalResults: number;
    startIndex: number;
    itemsPerPage: number;
    entries: {
      id: string;
      title: string;
      summary: string;
      published: string;
      updated: string;
      authors: { name: string; affiliation: string[] }[];
      doi: string;
      comment: string;
      journalReference: string;
      primaryCategory: string;
      categories: string[];
      links: string[];
    }[];
  }
⋮----
export const extractId = (value: string)
⋮----
export type SearchParams = z.infer<typeof SearchParamsSchema>;
⋮----
/**
 * Lightweight wrapper around ArXiv for academic / scholarly research articles.
 *
 * @see https://arxiv.org
 */
export class ArXivClient extends AIFunctionsProvider {
⋮----
constructor({
    apiBaseUrl = arxiv.API_BASE_URL,
    ky = defaultKy,
  }: {
    apiKey?: string;
    apiBaseUrl?: string;
    ky?: KyInstance;
})
⋮----
/**
   * Searches for research articles published on arXiv.
   */
⋮----
async search(queryOrOpts: string | arxiv.SearchParams)
````

## File: src/mastra/tools/brave-search.ts
````typescript
import { createTool } from "@mastra/core/tools";
import { z } from "zod";
import { BraveSearchClient } from "@agentic/brave-search";
import { env } from "process";
⋮----
/**
 * Configuration for Brave search
 */
interface BraveSearchConfig {
  apiKey?: string;
  maxResults?: number;
  timeout?: number;
}
⋮----
/**
 * Creates a configured Brave search tool
 */
export function createBraveSearchTool(config: BraveSearchConfig =
⋮----
// BraveSearchClient.search only accepts query string
⋮----
// Filter results after receiving them
⋮----
// score is optional and not directly provided by this API result structure
````

## File: src/mastra/tools/contentTools.ts
````typescript
/**
 * Content Tools Module
 *
 * This module defines tools that process content such as analyzing and formatting text.
 *
 * @module ContentTools
 */
⋮----
import { createTool } from "@mastra/core/tools";
import { z } from "zod";
⋮----
/**
 * Analyze Content Tool
 *
 * Analyzes the input content and returns analysis results.
 *
 * @remarks
 * Replace the stub analysis logic with a proper NLP or analysis algorithm.
 *
 * @param input.content - The text content to analyze.
 * @returns An object containing the analysis result.
 * @throws {Error} When analysis execution fails.
 */
⋮----
// Placeholder analysis: count words and characters.
⋮----
/**
 * Format Content Tool
 *
 * Formats the input content into a specified structure.
 *
 * @remarks
 * Replace the stub formatting logic with your desired formatting operations.
 *
 * @param input.content - The text content to format.
 * @returns An object containing the formatted content.
 * @throws {Error} When formatting fails.
 */
⋮----
// Example formatting: trim whitespace and normalize spacing.
````

## File: src/mastra/tools/document-tools.ts
````typescript
// filepath: c:\Users\dm\Documents\DeanmachinesAI\src\mastra\tools\document-tools.ts
/**
 * Document Tools Module
 *
 * This module defines tools that work with documents such as searching within repositories and embedding documents.
 *
 * @module DocumentTools
 */
⋮----
import { createTool } from "@mastra/core/tools";
import { z } from "zod";
⋮----
/**
 * Search Documents Tool
 *
 * Searches document repositories for documents matching the query criteria.
 *
 * @remarks
 * Replace the stub search logic with an actual document search implementation.
 *
 * @param input.query - The search query string.
 * @returns An object containing an array of found documents.
 * @throws {Error} When the search execution fails.
 */
/**
 * Document interface representing a searchable document.
 */
export interface Document {
  id: string;
  title: string;
  content: string;
}
⋮----
/**
 * Simulated document repository.
 *
 * In a real application, replace this in-memory array with calls to a database or external API.
 */
⋮----
/**
 * Search Documents Tool
 *
 * Searches document repositories for documents matching the query criteria.
 *
 * @remarks
 * This implementation performs a case-insensitive search over the document titles and content.
 *
 * @param input.query - The search query string.
 * @returns An object containing an array of found documents.
 * @throws {Error} When the search execution fails.
 */
⋮----
// Extract the query and sanitize it for case insensitive search.
⋮----
// Filter the repository for documents where either the title or content includes the query.
⋮----
/**
 * Embed Document Tool
 *
 * Generates an embedding vector representing the document content.
 *
 * @remarks
 * Replace the stub embedding logic with an actual embedding generator (e.g., a neural network model).
 *
 * @param input.document - The text content of the document.
 * @returns An object containing the embedding vector.
 * @throws {Error} When embedding computation fails.
 */
⋮----
// Example stub: simple transformation using character codes.
````

## File: src/mastra/tools/document.ts
````typescript
/**
 * Document processing tools for Mastra AI.
 *
 * This module provides tools for document chunking, parsing, and embedding
 * to support various document-based operations within Mastra agents.
 */
⋮----
import { createTool } from "@mastra/core/tools";
import { z } from "zod";
import { RecursiveCharacterTextSplitter } from "langchain/text_splitter";
import { Document } from "langchain/document";
import { Pinecone } from "@pinecone-database/pinecone"; // Import the main Pinecone client
import { PineconeStore } from "@langchain/pinecone"; // Import the LangChain Pinecone vector store
import { createEmbeddings } from "../database/vector-store";
import { createLangSmithRun, trackFeedback } from "../services/langsmith";
import { env } from "process";
⋮----
/**
 * Options for chunking documents
 */
interface ChunkingOptions {
  /** Maximum size of each chunk in characters */
  chunkSize?: number;
  /** Overlap between chunks to maintain context */
  chunkOverlap?: number;
  /** Minimum chunk size to include */
  minChunkSize?: number;
}
⋮----
/** Maximum size of each chunk in characters */
⋮----
/** Overlap between chunks to maintain context */
⋮----
/** Minimum chunk size to include */
⋮----
/**
 * Chunks text into smaller segments for processing
 *
 * @param text - The text content to chunk
 * @param options - Chunking configuration options
 * @returns Array of document chunks
 */
async function chunkText(
  text: string,
  options: ChunkingOptions = {}
): Promise<Document[]>
⋮----
/**
 * Tool for embedding documents into the vector store
 */
⋮----
// Create embeddings for vector store
⋮----
// Create document chunks
⋮----
// Enrich chunks with metadata
⋮----
// Initialize Pinecone client
⋮----
// Store document in vector database
⋮----
// Track successful embedding in LangSmith
⋮----
// Track failure in LangSmith
⋮----
/**
 * Tool for retrieving documents from vector storage
 */
⋮----
// Initialize Pinecone client
⋮----
// Perform similarity search with metadata filter if provided
⋮----
// Format results
⋮----
score: (doc as any).score ?? (doc.metadata as any)?.score, // Attempt to get score if available
⋮----
// Track successful retrieval in LangSmith
⋮----
// Track failure in LangSmith
⋮----
}, // Added comma here
````

## File: src/mastra/tools/e2b.ts
````typescript
import { createAIFunction, getEnv } from "@agentic/core";
import { Sandbox } from "@e2b/code-interpreter";
import { z } from "zod";
⋮----
/**
 * E2B Python code interpreter sandbox.
 *
 * @see https://e2b.dev
 */
````

## File: src/mastra/tools/exasearch.ts
````typescript
import { createTool } from "@mastra/core/tools";
import { z } from "zod";
import {
  searchWeb,
  searchWithFilters,
  searchForRAG,
  type ExaSearchConfig,
  type ExaSearchResult,
} from "../services/exasearch";
⋮----
// Export types for consumers
⋮----
/**
 * Exa search tool for web content retrieval
 */
⋮----
// Default export for easier importing
````

## File: src/mastra/tools/github.ts
````typescript
import { aiFunction, AIFunctionsProvider, assert, getEnv } from "@agentic/core";
import { Octokit } from "octokit";
import { z } from "zod";
⋮----
export interface User {
    id: number;
    login: string;
    name: string;
    bio: string;
    node_id: string;
    gravatar_id: string;
    type: string;
    site_admin: boolean;
    company: string;
    blog?: string;
    location?: string;
    hireable?: boolean;
    twitter_username?: string;
    email?: string;
    public_repos: number;
    public_gists: number;
    followers: number;
    following: number;
    avatar_url: string;
    url: string;
    html_url: string;
    followers_url: string;
    following_url: string;
    gists_url: string;
    starred_url: string;
    subscriptions_url: string;
    organizations_url: string;
    repos_url: string;
    events_url: string;
    received_events_url: string;
    created_at: string;
    updated_at: string;
  }
⋮----
/**
 * Agentic GitHub client.
 */
export class GitHubClient extends AIFunctionsProvider {
⋮----
constructor({
    apiKey = getEnv("GITHUB_API_KEY"),
  }: {
    apiKey?: string;
} =
⋮----
/**
   * Get a user by username.
   */
⋮----
async getUserByUsername(
    usernameOrOpts: string | { username: string }
): Promise<github.User>
````

## File: src/mastra/tools/hyper-functionCalls.ts
````typescript
import { google } from "@ai-sdk/google";
import { Hyperbrowser } from "@hyperbrowser/sdk";
import {
  WebsiteCrawlTool,
  WebsiteScrapeTool,
  WebsiteExtractTool,
} from "@hyperbrowser/sdk/tools";
import { env } from "process";
⋮----
/**
 * Initialize Hyperbrowser and Google AI clients
 */
⋮----
interface ToolCall {
  id: string;
  function: {
    name: string;
    arguments: string;
  };
}
⋮----
/**
 * Handles tool calls from the AI and executes corresponding actions
 */
async function handleToolCall(tc: ToolCall)
⋮----
/**
 * Runs an interactive chat session with AI using website tools
 */
async function chat()
⋮----
// Start the chat session
````

## File: src/mastra/tools/llamaindex.ts
````typescript
import {
  type AIFunctionLike,
  AIFunctionSet,
  asZodOrJsonSchema,
} from "@agentic/core";
import { FunctionTool } from "llamaindex";
⋮----
/**
 * Converts a set of Agentic stdlib AI functions to an array of LlamaIndex-
 * compatible tools.
 */
export function createLlamaIndexTools(
  ...aiFunctionLikeTools: AIFunctionLike[]
)
⋮----
// TODO: Investigate types here
````

## File: src/mastra/tools/mcp.ts
````typescript
import { createAISDKTools } from "@agentic/ai-sdk";
import { createMcpTools } from "@agentic/mcp";
import { google } from "@ai-sdk/google";
import { generateText } from "ai";
⋮----
async function main()
⋮----
// Create an MCP tools provider, which will start a local MCP server process
// and use the stdio transport to communicate with it.
⋮----
// This example uses a built-in example MCP server from Anthropic, which
// provides a set of tools to access the local filesystem.
⋮----
// Allow the MCP server to access the current working directory.
⋮----
// Feel free to add additional directories the tool should have access to.
⋮----
// Use the MCP tools provider to create a set of tools for the AI model.
````

## File: src/mastra/tools/mcptools.ts
````typescript
import type { Transport } from "@modelcontextprotocol/sdk/shared/transport.js";
import type {
  CallToolResult,
  ListToolsResult,
} from "@modelcontextprotocol/sdk/types.js";
import {
  AIFunctionSet,
  AIFunctionsProvider,
  assert,
  createAIFunction,
  createJsonSchema,
} from "@agentic/core";
import { Client as McpClient } from "@modelcontextprotocol/sdk/client/index.js";
import { type z } from "zod";
⋮----
import type { McpToolsFilter, McpToolsOptions } from "./types";
import { paginate } from "./paginate";
⋮----
/**
 * Agentic tools provider wrapping an MCP client.
 *
 * You likely want to use `createMcpTools` to create an instance of `McpTools`
 * which enables exposing MCP server tools to the agentic ecosystem.
 *
 * @see https://modelcontextprotocol.io
 */
export class McpTools extends AIFunctionsProvider {
⋮----
protected constructor({
    name,
    client,
    toolsFilter,
    rawToolResponses = false,
  }: {
    client: McpClient;
} & McpToolsOptions)
⋮----
override get functions(): AIFunctionSet
⋮----
/**
   * Initialize the McpTools instance by fetching all available tools from the MCP client.
   * This method must be called before using this class' tools.
   * It is called automatically when using `McpTools.from()`.
   */
protected async _init()
⋮----
// TODO: handle prompts, resources, etc.
⋮----
protected async _initTools()
⋮----
protected _updateFunctions()
⋮----
async callTool(name: string, args: z.infer<z.ZodObject<any>>)
⋮----
/**
   * Creates a new McpTools instance from an existing, fully initialized
   * MCP client.
   *
   * You probably want to use `createMcpTool` instead, which makes initializing
   * the MCP client and connecting to its transport easier.
   *
   * All tools within the `McpTools` instance will be namespaced under the given
   * `name`.
   */
static async fromMcpClient(params:
⋮----
/**
 * Creates a new McpTools instance by connecting to an MCP server. You must
 * provide either an existing `transport`, an existing `serverUrl`, or a
 * `serverProcess` to spawn.
 *
 * All tools within the `McpTools` instance will be namespaced under the given
 * `name`.
 */
export async function createMcpTools(
  params: McpToolsOptions
): Promise<McpTools>
⋮----
/**
 * Creates a new MCP transport from either an existing `transport`, an existing
 * `serverUrl`, or a `serverProcess` to spawn.
 */
export async function createMcpTransport(
  params: McpToolsOptions
): Promise<Transport>
⋮----
function toText(c: CallToolResult["content"])
⋮----
function processToolCallResult(result: CallToolResult)
````

## File: src/mastra/tools/paginate.ts
````typescript
export interface PaginateInput<T, C> {
  size: number;
  handler: (data: {
    cursor?: C;
    limit: number;
  }) => Promise<{ data: T[]; nextCursor?: C }>;
}
⋮----
export async function paginate<T, C = number>(
  input: PaginateInput<T, C>
): Promise<T[]>
````

## File: src/mastra/tools/tavily.ts
````typescript
import { createTool } from "@mastra/core/tools";
import { z } from "zod";
import { TavilyClient } from "@agentic/tavily";
import { env } from "process";
⋮----
/**
 * Configuration for Tavily search
 */
interface TavilyConfig {
  apiKey?: string;
}
⋮----
/**
 * Creates a configured Tavily search tool
 */
export function createTavilySearchTool(config: TavilyConfig =
````

## File: src/mastra/tools/types.ts
````typescript
import type { StdioServerParameters } from "@modelcontextprotocol/sdk/client/stdio.js";
import type { Transport } from "@modelcontextprotocol/sdk/shared/transport.js";
⋮----
export type McpToolsFilter = (toolName: string) => boolean;
⋮----
export interface McpToolsOptions {
  /**
   * Provide a name for this client which will be its namespace for all tools and prompts.
   */
  name: string;

  /**
   * Provide a version number for this client (defaults to 1.0.0).
   */
  version?: string;

  /**
   * If you already have an MCP transport you'd like to use, pass it here to connect to the server.
   */
  transport?: Transport;

  /**
   * Start a local server process using the stdio MCP transport.
   */
  serverProcess?: StdioServerParameters;

  /**
   * Connect to a remote server process using the SSE MCP transport.
   */
  serverUrl?: string;

  /**
   * Return tool responses in raw MCP form instead of processing them for Genkit compatibility.
   */
  rawToolResponses?: boolean;

  /**
   * An optional filter function to determine which tools should be enabled.
   *
   * By default, all tools available on the MCP server will be enabled, but you
   * can use this to filter a subset of those tools.
   */
  toolsFilter?: McpToolsFilter;
}
⋮----
/**
   * Provide a name for this client which will be its namespace for all tools and prompts.
   */
⋮----
/**
   * Provide a version number for this client (defaults to 1.0.0).
   */
⋮----
/**
   * If you already have an MCP transport you'd like to use, pass it here to connect to the server.
   */
⋮----
/**
   * Start a local server process using the stdio MCP transport.
   */
⋮----
/**
   * Connect to a remote server process using the SSE MCP transport.
   */
⋮----
/**
   * Return tool responses in raw MCP form instead of processing them for Genkit compatibility.
   */
⋮----
/**
   * An optional filter function to determine which tools should be enabled.
   *
   * By default, all tools available on the MCP server will be enabled, but you
   * can use this to filter a subset of those tools.
   */
⋮----
// TODO
// export interface McpServerOptions {
//   /** The name you want to give your server for MCP inspection. */
//   name: string
//
//   /** The version you want the server to advertise to clients. Defaults to 1.0.0. */
//   version?: string
// }
````

## File: src/mastra/tools/utils.ts
````typescript
export function hasProp<T>(
  target: T | undefined,
  key: keyof T
): key is keyof T
⋮----
export function getProp(
  target: unknown,
  paths: readonly (keyof any)[],
  defaultValue: any = undefined
)
⋮----
export function castArray<T>(arr: T)
````

## File: src/mastra/tools/wikibase.ts
````typescript
import {
  aiFunction,
  AIFunctionsProvider,
  assert,
  getEnv,
  throttleKy,
} from "@agentic/core";
import defaultKy, { type KyInstance } from "ky";
import pThrottle from "p-throttle";
import { z } from "zod";
⋮----
// Allow up to 200 requests per second by default.
⋮----
export interface SearchOptions {
    query: string;
    limit?: number;
  }
⋮----
export interface PageSearchResponse {
    pages: Page[];
  }
⋮----
export interface Page {
    id: number;
    key: string;
    title: string;
    matched_title: null;
    excerpt: string;
    description: null | string;
    thumbnail: Thumbnail | null;
  }
⋮----
export interface Thumbnail {
    url: string;
    width: number;
    height: number;
    mimetype: string;
    duration: null;
  }
⋮----
export interface PageSummaryOptions {
    title: string;
    redirect?: boolean;
    acceptLanguage?: string;
  }
⋮----
export interface PageSummaryResponse {
    ns?: number;
    index?: number;
    type: string;
    title: string;
    displaytitle: string;
    namespace: { id: number; text: string };
    wikibase_item: string;
    titles: { canonical: string; normalized: string; display: string };
    pageid: number;
    thumbnail: {
      source: string;
      width: number;
      height: number;
    };
    originalimage: {
      source: string;
      width: number;
      height: number;
    };
    lang: string;
    dir: string;
    revision: string;
    tid: string;
    timestamp: string;
    description: string;
    description_source: string;
    content_urls: {
      desktop: {
        page: string;
        revisions: string;
        edit: string;
        talk: string;
      };
      mobile: {
        page: string;
        revisions: string;
        edit: string;
        talk: string;
      };
    };
    extract: string;
    extract_html: string;
    normalizedtitle?: string;
    coordinates?: {
      lat: number;
      lon: number;
    };
  }
⋮----
/**
 * Basic Wikipedia API client for searching wiki pages and resolving page data.
 *
 * @see https://www.mediawiki.org/wiki/API
 */
export class WikipediaClient extends AIFunctionsProvider {
⋮----
constructor({
    apiBaseUrl = getEnv("WIKIPEDIA_API_BASE_URL") ??
      "https://en.wikipedia.org/api/rest_v1",
    apiUserAgent = getEnv("WIKIPEDIA_API_USER_AGENT") ??
      "Agentic (https://github.com/transitive-bullshit/agentic)",
    throttle = true,
    ky = defaultKy,
  }: {
    apiBaseUrl?: string;
    apiUserAgent?: string;
    throttle?: boolean;
    ky?: KyInstance;
} =
⋮----
/**
   * Searches Wikipedia for pages matching the given query. */
⋮----
async search(
⋮----
// https://www.mediawiki.org/wiki/API:REST_API
⋮----
/**
   * Gets a summary of the given Wikipedia page.
   */
⋮----
async getPageSummary({
    title,
    acceptLanguage = "en-us",
    redirect = true,
    ...opts
}: wikipedia.PageSummaryOptions)
⋮----
// https://en.wikipedia.org/api/rest_v1/
````

## File: src/mastra/utils/index.ts
````typescript
/**
 * Utility exports for DeanmachinesAI
 *
 * This module exports various utilities to support the application's functionality.
 */
````

## File: src/mastra/utils/thread-manager.ts
````typescript
/**
 * Thread Manager for consistent memory persistence
 *
 * This utility helps manage thread IDs consistently across conversations,
 * ensuring that memory context is properly maintained and retrieved.
 */
⋮----
import { randomUUID } from "crypto";
⋮----
/**
 * Thread information with creation metadata
 */
interface ThreadInfo {
  /** Unique thread identifier */
  id: string;
  /** User or entity associated with the thread */
  resourceId: string;
  /** When the thread was created */
  createdAt: Date;
  /** Optional metadata for thread categorization */
  metadata?: Record<string, unknown>;
}
⋮----
/** Unique thread identifier */
⋮----
/** User or entity associated with the thread */
⋮----
/** When the thread was created */
⋮----
/** Optional metadata for thread categorization */
⋮----
/**
 * Thread creation options
 */
interface CreateThreadOptions {
  /** Optional predefined thread ID (generates UUID if not provided) */
  threadId?: string;
  /** User or entity associated with the thread */
  resourceId: string;
  /** Optional metadata for thread categorization */
  metadata?: Record<string, unknown>;
}
⋮----
/** Optional predefined thread ID (generates UUID if not provided) */
⋮----
/** User or entity associated with the thread */
⋮----
/** Optional metadata for thread categorization */
⋮----
/**
 * Manages conversation threads to ensure consistent memory access
 */
export class ThreadManager {
⋮----
/**
   * Creates a new conversation thread
   *
   * @param options - Thread creation options
   * @returns Thread information including the ID
   */
public createThread(options: CreateThreadOptions): ThreadInfo
⋮----
// Track threads by resource ID for easier lookup
⋮----
/**
   * Retrieves a thread by its ID
   *
   * @param threadId - The ID of the thread to retrieve
   * @returns Thread information or undefined if not found
   */
public getThread(threadId: string): ThreadInfo | undefined
⋮----
/**
   * Gets all threads associated with a resource ID
   *
   * @param resourceId - The resource ID to look up threads for
   * @returns Array of thread information objects
   */
public getThreadsByResource(resourceId: string): ThreadInfo[]
⋮----
/**
   * Gets the most recent thread for a resource
   *
   * @param resourceId - The resource ID to find the most recent thread for
   * @returns Most recent thread information or undefined if none exists
   */
public getMostRecentThread(resourceId: string): ThreadInfo | undefined
⋮----
/**
   * Creates or retrieves a thread for a resource ID
   *
   * @param resourceId - The resource ID to get or create a thread for
   * @param metadata - Optional metadata for the thread if created
   * @returns Thread information with a consistent ID
   */
public getOrCreateThread(
    resourceId: string,
    metadata?: Record<string, unknown>
): ThreadInfo
⋮----
// Export a singleton instance for app-wide use
````

## File: src/mastra/voice/elevenlabs.ts
````typescript
/**
 * ElevenLabs Voice implementation for Mastra
 *
 * This module provides high-quality text-to-speech capabilities
 * using the ElevenLabs API with the Mastra voice interface.
 */
⋮----
import { MastraVoice } from "@mastra/core/voice";
import { ElevenLabsVoice } from "@mastra/voice-elevenlabs";
⋮----
/**
 * Interface for ElevenLabs voice configuration options
 */
interface ElevenLabsConfig {
  /** API key for ElevenLabs services */
  apiKey?: string;
  /** Default speaker/voice ID */
  speaker?: string;
  /** Model name to use for speech synthesis */
  modelName?: string;
}
⋮----
/** API key for ElevenLabs services */
⋮----
/** Default speaker/voice ID */
⋮----
/** Model name to use for speech synthesis */
⋮----
/**
 * Create an ElevenLabs voice provider with the specified configuration
 *
 * @param config - Configuration options for the ElevenLabs voice provider
 * @returns Configured ElevenLabs voice provider instance
 * @throws Error if required environment variables are missing
 */
export function createElevenLabsVoice(
  config: ElevenLabsConfig = {}
): MastraVoice
⋮----
speaker: voiceName, // Use the defined voiceName variable
````

## File: src/mastra/voice/googlevoice.ts
````typescript
/**
 * Google Voice implementation for Mastra
 *
 * This module provides text-to-speech and speech-to-text capabilities
 * using Google Cloud services with the Mastra voice interface.
 */
⋮----
import { MastraVoice } from "@mastra/core/voice";
import { GoogleVoice as GoogleVoiceProvider } from "@mastra/voice-google";
⋮----
/**
 * Interface for Google voice configuration options
 */
interface GoogleVoiceConfig {
  /** API key for Google Cloud services */
  apiKey?: string;
  /** Default speaker/voice ID */
  speaker?: string;
  /** Options for speech-to-text model */
  listeningOptions?: {
    /** Language code for speech recognition */
    languageCode?: string;
    /** Audio encoding format */
    encoding?: string;
  };
  /** Options for text-to-speech model */
  speechOptions?: {
    /** Language code for speech synthesis */
    languageCode?: string;
    /** Audio encoding format */
    audioEncoding?: string;
  };
}
⋮----
/** API key for Google Cloud services */
⋮----
/** Default speaker/voice ID */
⋮----
/** Options for speech-to-text model */
⋮----
/** Language code for speech recognition */
⋮----
/** Audio encoding format */
⋮----
/** Options for text-to-speech model */
⋮----
/** Language code for speech synthesis */
⋮----
/** Audio encoding format */
⋮----
/**
 * Create a Google voice provider with the specified configuration
 *
 * @param config - Configuration options for the Google voice provider
 * @returns Configured Google voice provider instance
 * @throws Error if required environment variables are missing
 */
export function createGoogleVoice(config: GoogleVoiceConfig =
````

## File: src/mastra/voice/index.ts
````typescript
/**
 * Voice module for Mastra
 *
 * This module provides voice capabilities for Mastra agents,
 * including text-to-speech, speech-to-text, and speech-to-speech
 * functionalities using different provider implementations.
 */
⋮----
import { MastraVoice } from "@mastra/core/voice";
import { createGoogleVoice } from "./googlevoice";
import { createElevenLabsVoice } from "./elevenlabs";
⋮----
/**
 * Available voice provider types
 */
export enum VoiceProvider {
  GOOGLE = "google",
  ELEVENLABS = "elevenlabs",
}
⋮----
/**
 * Configuration for voice providers
 */
export interface VoiceConfig {
  /** Provider type to use */
  provider: VoiceProvider;
  /** API key for the voice service */
  apiKey?: string;
  /** Default speaker ID */
  speaker?: string;
  /** Provider-specific options */
  options?: Record<string, unknown>;
}
⋮----
/** Provider type to use */
⋮----
/** API key for the voice service */
⋮----
/** Default speaker ID */
⋮----
/** Provider-specific options */
⋮----
/**
 * Create a voice provider based on the specified configuration
 *
 * @param config - Voice provider configuration
 * @returns Configured voice provider instance
 * @throws Error if the specified provider is not supported
 */
export function createVoice(config: VoiceConfig): MastraVoice
⋮----
/**
 * Helper to get a Google voice provider with default settings
 *
 * @returns Google voice provider instance
 */
export function getGoogleVoice(): MastraVoice
⋮----
/**
 * Helper to get an ElevenLabs voice provider with default settings
 *
 * @returns ElevenLabs voice provider instance
 */
export function getElevenLabsVoice(): MastraVoice
⋮----
// Export all voice-related functions and types
⋮----
// Re-export the MastraVoice type for external use
````

## File: src/mastra/workflows/Networks/knowledgeWorkMoE.network.ts
````typescript
/**
 * @file src/mastra/workflows/Networks/knowledgeWorkMoE.network.ts
 * @description Implements a highly optimized and robust Mixture of Experts (MoE) network
 *              using Mastra's AgentNetwork framework. Routes tasks to the most
 *              appropriate specialized agent based on rules or LLM routing.
 * @version 2.0.0 - Optimized & Refined
 */
⋮----
import { Agent } from "@mastra/core/agent";
import { AgentNetwork, type AgentNetworkConfig } from "@mastra/core/network";
import { createLogger } from "@mastra/core/logger";
import { z } from "zod";
import { type CoreMessage } from "ai"; // Import CoreMessage from the main 'ai' package
⋮----
// Import the actual agents map (value) and necessary config types/utils
// Assuming the export from '../../agents' is named 'allAgents'
import allAgents from "../../agents"; // Use default import
import {
  ModelConfig,
  createModelInstance,
  DEFAULT_MODELS,
} from "../../agents/config";
import { sharedMemory } from "../../database"; // Import shared memory
⋮----
// Define the type for the agents map more explicitly
type AgentRegistry = typeof allAgents;
// Define a type for valid agent IDs based on the registry keys
type AgentId = keyof AgentRegistry;
⋮----
// --- Constants ---
const DEFAULT_FALLBACK_AGENT_ID: AgentId = "agenticAssistant"; // Use type safety
⋮----
/**
 * Represents a Mixture of Experts (MoE) network built on Mastra's AgentNetwork.
 *
 * This network intelligently routes an incoming task to the single most suitable
 * expert agent from a predefined pool. It uses high-confidence rules for common
 * tasks and falls back to an LLM-based router for more complex or ambiguous requests.
 * Includes robust fallback mechanisms and optimized execution flow.
 */
export class KnowledgeWorkMoENetwork extends AgentNetwork {
⋮----
// Map storing only the Agent instances actively used as experts in this network.
⋮----
// Reference to the complete agent registry provided during construction.
⋮----
// The ID of the agent designated as the fallback.
⋮----
// The unique identifier for this network instance.
⋮----
/**
   * Creates an instance of KnowledgeWorkMoENetwork.
   *
   * @param expertAgentIds - An array of agent IDs (keys of agentRegistry) to include as experts.
   *                         These agents must exist and be valid Agent instances in the registry.
   * @param agentRegistry - The complete map of all available agents (imported from `src/mastra/agents`).
   *                        Must not be empty.
   * @param routerModelConfig - Configuration for the Language Model used for routing decisions.
   *                            Choose a model capable of following instructions accurately.
   * @param networkId - A unique identifier string for this network instance (e.g., "knowledge-work-moe-v1").
   * @param fallbackAgentId - The ID of the agent (must be in agentRegistry) to use if routing or execution fails.
   *                          Defaults to "agentic-assistant".
   * @throws {Error} If the agentRegistry is empty, no valid expert agents are found,
   *                 or the specified fallbackAgentId is invalid.
   */
constructor(
    expertAgentIds: AgentId[],
    agentRegistry: AgentRegistry,
    routerModelConfig: ModelConfig,
    networkId: string = "knowledge-work-moe",
    fallbackAgentId: AgentId = DEFAULT_FALLBACK_AGENT_ID
)
⋮----
// --- Input Validation ---
⋮----
// --- Prepare Configuration for super() without using 'this' ---
⋮----
// --- Dynamic Expert Registration & Description Building (Local) ---
⋮----
const agent = agentRegistry[id]; // Use parameter directly
⋮----
logger.info(`[${networkId}] Registered expert: ${id}`); // Use parameter
⋮----
`[${networkId}] Specified expert agent ID "${id}" not found or invalid in registry. Skipping.` // Use parameter
⋮----
// --- Validate that at least one expert was successfully registered (Local) ---
⋮----
`[${networkId}] Initialization failed: No valid expert agents were found in the registry based on the provided IDs.` // Use parameter
⋮----
// --- Validate and Ensure Fallback Agent is Included (Local) ---
const fallbackAgent = agentRegistry[fallbackAgentId]; // Use parameters directly
⋮----
`[${networkId}] CRITICAL CONFIGURATION ERROR: Specified fallback agent "${fallbackAgentId}" is not a valid Agent instance in the registry. Fallback mechanism WILL FAIL.` // Use parameters
⋮----
`[${networkId}] Invalid fallback agent ID specified: "${fallbackAgentId}".` // Use parameters
⋮----
`[${networkId}] Adding valid fallback agent "${fallbackAgentId}" to network's agent list.` // Use parameters
⋮----
`[${networkId}] Final expert descriptions for router:\n${expertDescriptions}` // Use parameter
⋮----
// --- Crafting Instructions for the Internal Router (Crucial for MoE Behavior) ---
⋮----
// --- AgentNetwork Configuration ---
⋮----
name: `Knowledge Work MoE Network (${networkId})`, // Use parameter
// description: // Removed as it's not part of AgentNetworkConfig
//   "Routes tasks to the most appropriate specialized agent using rules or LLM routing.",
agents: localExpertAgentsForBaseConfig, // Use local list
⋮----
// memory: sharedMemory, // Memory might be handled differently or implicitly by the base class
// hooks: {} // Add hooks if needed
⋮----
// --- Initialize the Base AgentNetwork (MUST be called before 'this') ---
⋮----
// --- Assign instance properties AFTER super() ---
⋮----
this.expertAgentsMap = localExpertAgentsMap; // Assign the map built locally
⋮----
/**
   * Applies high-confidence, specific rule-based routing for common tasks.
   * Rules are ordered by likely specificity.
   *
   * @param userInput - The user's input string, trimmed and lowercased.
   * @returns The ID of the expert if a high-confidence rule matches, otherwise null.
   */
private _applyRuleBasedRouting(userInput: string): AgentId | null
⋮----
// --- High-Confidence Rule-Based Shortcuts ---
⋮----
// Group: Debugging & Code Fixing (High Specificity)
⋮----
// Group: Code Documentation & Explanation
⋮----
// Assuming 'codeDocumenterAgent' is the correct AgentId key
⋮----
// Group: UI/Frontend Development
⋮----
// Assuming 'uiUxCoderAgent' is the correct AgentId key
⋮----
// Group: Architecture & Design
⋮----
// Redundant return removed
⋮----
// Group: Code Refactoring
⋮----
// Redundant return removed
⋮----
// Group: General Code Generation (Less specific than others above)
⋮----
// Removed extra closing brace and redundant return
⋮----
// Group: Research & Information Gathering
// Corrected structure and added conditions
⋮----
// Removed extra closing braces and misplaced return
⋮----
// Group: Data Analysis & Interpretation
⋮----
// Group: Marketing Research
⋮----
// Group: Copywriting & Marketing Content
⋮----
// Assuming 'copywriterAgent' is the correct AgentId key
⋮----
// Group: Social Media Content
// Corrected structure and added conditions
⋮----
// Assuming 'socialMediaAgent' is the correct AgentId key
⋮----
// Removed extra closing braces and misplaced return
⋮----
// Group: SEO & Keywords
⋮----
// Assuming 'seoAgent' is the correct AgentId key
⋮----
// Redundant return removed
⋮----
// Group: Data/File/Vector Management
// Corrected structure and added conditions
⋮----
// Removed extra closing braces and misplaced return
⋮----
// Group: General Writing/Summarization/Explanation (Lower Specificity)
// Corrected structure and added conditions
⋮----
// Removed extra closing braces and misplaced return
⋮----
// --- End Rules ---
⋮----
return null; // No rule matched
⋮----
/**
   * Executes the MoE network logic, overriding the base class method.
   * It first attempts rule-based routing, then falls back to LLM-based routing
   * provided by the base AgentNetwork, and finally uses a designated fallback agent
   * if primary methods fail.
   *
   * @param input - The user input, which can be a string or a structured object.
   * @param options - Optional execution parameters, potentially including a threadId
   *                  or other contextual information.
   * @returns A promise that resolves to the output generated by the selected expert
   *          agent or the fallback agent.
   * @throws {Error} If both the primary execution path (rule-based or LLM-routed)
   *                 and the fallback agent execution fail, or if the fallback agent
   *                 is configured incorrectly.
   */
public async execute(
    input: string | Record<string, any>,
    options?: { threadId?: string; [key: string]: any }
): Promise<any>
⋮----
// Ensure input is string for rule matching, but pass original input to agents
⋮----
// 1. Try Rule-Based Routing
⋮----
// Directly execute the agent, passing the stringified input and the full options object
// Note: Agent.generate expects string | messages[], so we use inputString here.
// If agents need structured data, the LLM router path (super.execute)
// might handle it differently, or agents must parse the stringified object.
⋮----
// Construct arguments for agent.generate, ensuring required fields are present.
// The ruleBasedExpertId is the correct ID to use as the resourceId.
⋮----
// This check is technically redundant now if ruleBasedExpertId is always a valid AgentId string,
// but kept for robustness in case AgentId type changes.
⋮----
// Fallback if resourceId cannot be determined
⋮----
// Prepare arguments, ensuring resourceId and a string threadId are included.
⋮----
...(options ?? {}), // Spread original options
resourceId: agentResourceId, // Add required resourceId
⋮----
// Ensure threadId is a string, providing a temporary one if missing.
// Consider if a default threadId is appropriate or if it should be required.
⋮----
// Call generate with the constructed arguments object
⋮----
// If the high-confidence rule-based choice fails, trigger fallback directly.
⋮----
// Fall through to LLM router if rule points to non-existent agent (should be rare)
⋮----
// 2. If no rule matched, use the standard AgentNetwork LLM routing
⋮----
// Call the base class run method. It handles LLM routing and execution.
// Pass the original input and full options object.
// Prepare messages for the base class generate method
⋮----
// Convert structured input to a user message with stringified JSON
// The base network router needs to understand this format or be adapted.
⋮----
// Prepare arguments for the base class generate method, ensuring required fields.
⋮----
...(options ?? {}), // Spread original options
resourceId: this.networkId, // Use the network's ID as the resourceId for routing
⋮----
// Ensure threadId is a string, providing a temporary one if missing.
⋮----
// Call the base class generate method with correctly typed messages and args
// We need to cast baseGenerateArgs to the expected type, or ensure it matches.
// Assuming AgentGenerateOptions requires resourceId and threadId.
// Let's refine the type assertion or structure if needed based on AgentGenerateOptions definition.
// For now, casting to 'any' bypasses strict checks, but ideally, we'd match the type.
// A safer approach is to explicitly define the required properties.
const result = await super.generate(messages, baseGenerateArgs as any); // Cast needed if type mismatch persists
⋮----
// This catches errors during the base execute call (router or LLM-selected expert failure).
⋮----
// Attempt fallback if the main network execution fails
⋮----
/**
   * Executes the designated fallback agent when primary execution paths fail.
   * Internal helper method. Ensures fallback agent exists and handles its errors.
   *
   * @param originalInput - The original input to the network.
   * @param options - Original execution options potentially containing context like threadId.
   * @param failureReason - A string describing why the fallback is being triggered.
   * @returns {Promise<any>} The result from the fallback agent.
   * @throws {Error} If the fallback agent is unavailable or fails during its execution.
   */
private async executeFallback(
    originalInput: string | Record<string, any>,
    options: { threadId?: string; [key: string]: any } | undefined,
    failureReason: string
): Promise<any>
⋮----
const fallbackAgent = this.expertAgentsMap.get(this.fallbackAgentId); // Get from network's map
⋮----
// Critical check: Ensure the fallback agent instance is available in this network.
⋮----
// Throw a specific error indicating fallback failure due to unavailability.
⋮----
} // End of the critical check block
⋮----
// If the fallback agent *is* available, proceed with execution inside a try...catch
⋮----
// Execute the fallback agent. Convert input to string if it's an object,
// as generate expects string | messages[].
⋮----
// Prepare arguments, ensuring resourceId and a string threadId are included.
⋮----
...(options ?? {}), // Spread original options
resourceId: this.fallbackAgentId, // Use the fallback agent's ID
⋮----
// Ensure threadId is a string, providing a temporary one if missing.
⋮----
// Call generate with the constructed arguments object
⋮----
// If the fallback itself fails, log critical error and re-throw.
⋮----
// === Example Instantiation and Integration (For Reference) ===
// (Keep the example commented out as before, ensuring it reflects the final code structure)
/*
// 1. Import necessary components in `src/mastra/workflows/Networks/agentNetwork.ts`
import { KnowledgeWorkMoENetwork } from './knowledgeWorkMoE.network';
import { agents } from '../../agents'; // Import the full agent registry
import { DEFAULT_MODELS } from '../../agents/config';

// 2. Define the list of expert agent IDs for this specific MoE network instance
const moeExpertIds: Array<keyof typeof agents> = [
  'research-agent', 'analyst-agent', 'writer-agent', 'coder-agent',
  'debugger-agent', 'architect-agent', 'code-documenter-agent',
  'data-manager-agent', 'market-research-agent', 'copywriter-agent',
  'social-media-agent', 'seo-agent', 'ui-ux-coder-agent',
  // 'agentic-assistant' // Fallback agent added automatically if valid & not listed.
];

// 3. Configure the router model
const routerConfig = DEFAULT_MODELS.GOOGLE_STANDARD;

// 4. Instantiate the network
export const knowledgeWorkMoENetwork = new KnowledgeWorkMoENetwork(
  moeExpertIds,
  agents,
  routerConfig,
  "knowledge-work-moe-v1"
);

// 5. Add to the main networks export in `src/mastra/workflows/Networks/agentNetwork.ts`
// export const networks = { /* ... other networks * / knowledgeWorkMoE: knowledgeWorkMoENetwork };

// 6. Ensure Mastra instance loads these networks (in src/mastra/index.ts)
// import { networks } from "./workflows/Networks/agentNetwork";
// export const mastra = new Mastra({ agents: allAgents, networks: networks, ... });

// 7. Example Invocation via Mastra instance
// async function runMoEExamples() { ... } // (As in previous example)
// runMoEExamples();
*/
````

## File: tsconfig.json
````json
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "dist"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}
````

## File: mastra.config.ts
````typescript
import { Mastra } from "@mastra/core";
import { createLogger } from "@mastra/core/logger";
import {
  researchAgent,
  analystAgent,
  writerAgent,
  rlTrainerAgent,
  dataManagerAgent,
} from "./src/mastra/agents";
import { ragWorkflow, networks } from "./src/mastra/workflows";
⋮----
// Track request timing for RL metrics
````

## File: src/mastra/agents/config/config.types.ts
````typescript
/**
 * Agent Configuration Type Definitions
 *
 * This module defines shared types and interfaces for agent configurations,
 * ensuring consistent typing across the agent configuration system.
 *
 * @module config.types
 */
⋮----
import { z } from "zod";
import { google } from "@ai-sdk/google";
import { vertex } from "@ai-sdk/google-vertex";
import { Tool } from "@mastra/core/tools";
⋮----
/**
 * Supported AI model providers
 */
export type ModelProvider = "google" | "vertex" | "openai";
⋮----
/** Default Maximum Tokens for Model Output */
⋮----
/** Default Maximum Context Tokens for Model Input */
⋮----
/**
 * Model capabilities and features supported
 * These represent the different capabilities models may have
 */
export interface ModelCapabilities {
  /** Maximum context window size in tokens */
  maxContextTokens: number;
  /** Whether the model supports multimodal inputs (images, audio, video) */
  multimodalInput: boolean;
  /** Whether the model supports image generation output */
  imageGeneration: boolean;
  /** Whether the model supports audio output */
  audioOutput: boolean;
  /** Whether the model supports function/tool calling */
  functionCalling: boolean;
  /** Whether the model supports structured output (JSON, etc) */
  structuredOutput: boolean;
  /** Whether the model has enhanced reasoning/thinking capabilities */
  enhancedThinking: boolean;
  /** Whether the model supports grounding to reduce hallucinations */
  grounding: boolean;
  /** Whether the model supports response caching for efficiency */
  responseCaching: boolean;
}
⋮----
/** Maximum context window size in tokens */
⋮----
/** Whether the model supports multimodal inputs (images, audio, video) */
⋮----
/** Whether the model supports image generation output */
⋮----
/** Whether the model supports audio output */
⋮----
/** Whether the model supports function/tool calling */
⋮----
/** Whether the model supports structured output (JSON, etc) */
⋮----
/** Whether the model has enhanced reasoning/thinking capabilities */
⋮----
/** Whether the model supports grounding to reduce hallucinations */
⋮----
/** Whether the model supports response caching for efficiency */
⋮----
/**
 * Default model configurations for different use cases
 * Based on https://ai.google.dev/gemini-api/docs/models
 */
⋮----
// GOOGLE PROVIDER MODELS
⋮----
// Standard Google model - fast, versatile
⋮----
audioOutput: false, // Coming soon according to docs
⋮----
// Premium Google model - enhanced reasoning and capability
⋮----
// Cost-efficient Google model - better for bulk processing
⋮----
// Enhanced thinking experimental model - special capabilities
⋮----
// VERTEX AI PROVIDER MODELS
⋮----
// Vertex AI model - for enterprise features and security
⋮----
// Advanced Vertex model - for enterprise use cases
⋮----
// Premium Vertex model - highest capability enterprise model
⋮----
/**
 * Type for accessing default model configurations
 */
export type DefaultModelKey = keyof typeof DEFAULT_MODELS;
⋮----
/** Default Google AI Model ID */
⋮----
/**
 * Function calling configuration for Vertex AI models
 * Based on https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/function-calling
 */
export interface FunctionCallingConfig {
  /**
   * Function calling mode
   * - AUTO: Default model behavior, can respond with function call or natural language
   * - NONE: Model doesn't make predictions as function calls
   * - ANY: Model is constrained to always predict a function call
   */
  mode: "AUTO" | "NONE" | "ANY";

  /**
   * List of function names that the model is allowed to call
   * Only set when mode is ANY
   * Empty array means the model can choose from all available functions
   */
  allowedFunctionNames: string[];
}
⋮----
/**
   * Function calling mode
   * - AUTO: Default model behavior, can respond with function call or natural language
   * - NONE: Model doesn't make predictions as function calls
   * - ANY: Model is constrained to always predict a function call
   */
⋮----
/**
   * List of function names that the model is allowed to call
   * Only set when mode is ANY
   * Empty array means the model can choose from all available functions
   */
⋮----
/**
 * Model configuration options
 */
export interface ModelConfig {
  /** The provider to use for this agent */
  provider: ModelProvider;

  /** Model ID to use (e.g., "gemini-2.0-flash") */
  modelId: string;

  /** Maximum tokens to generate */
  maxTokens?: number;

  /** Temperature for generation (0-1) */
  temperature?: number;

  /** Top-p for sampling */
  topP?: number;

  /**
   * Function calling configuration
   * - For Google models: true/false to enable/disable function calling
   * - For Vertex AI models: FunctionCallingConfig object with mode and allowed function names
   */
  functionCalling?: boolean | FunctionCallingConfig;

  /** Provider-specific options */
  providerOptions?: Record<string, unknown>;
}
⋮----
/** The provider to use for this agent */
⋮----
/** Model ID to use (e.g., "gemini-2.0-flash") */
⋮----
/** Maximum tokens to generate */
⋮----
/** Temperature for generation (0-1) */
⋮----
/** Top-p for sampling */
⋮----
/**
   * Function calling configuration
   * - For Google models: true/false to enable/disable function calling
   * - For Vertex AI models: FunctionCallingConfig object with mode and allowed function names
   */
⋮----
/** Provider-specific options */
⋮----
/**
 * Response hook options interface
 */
export interface ResponseHookOptions {
  minResponseLength?: number;
  maxAttempts?: number;
  validateResponse?: (response: unknown) => boolean;
}
⋮----
/**
 * Base configuration interface for all agent configs
 *
 * @interface BaseAgentConfig
 */
export interface BaseAgentConfig {
  /** Unique identifier for the agent */
  id: string;

  /** Display name of the agent */
  name: string;

  /** Brief description of the agent's purpose and capabilities */
  description: string;

  /**
   * Model configuration for creating the model dynamically
   * This is used to initialize the appropriate model (Google or Vertex AI)
   */
  modelConfig: ModelConfig;

  /** Main instructions that define the agent's behavior */
  instructions: string;

  /** Tool IDs that this agent has access to */
  toolIds: string[];

  /** Optional response validation settings */
  responseValidation?: ResponseHookOptions;

  /** Optional tools configuration */
  tools?: Tool[];
}
⋮----
/** Unique identifier for the agent */
⋮----
/** Display name of the agent */
⋮----
/** Brief description of the agent's purpose and capabilities */
⋮----
/**
   * Model configuration for creating the model dynamically
   * This is used to initialize the appropriate model (Google or Vertex AI)
   */
⋮----
/** Main instructions that define the agent's behavior */
⋮----
/** Tool IDs that this agent has access to */
⋮----
/** Optional response validation settings */
⋮----
/** Optional tools configuration */
⋮----
/**
 * Helper function to get a model configuration by key with optional overrides
 *
 * @param modelKey - The key of the default model to use
 * @param overrides - Optional properties to override in the default configuration
 * @returns A model configuration
 */
export function getModelConfig(
  modelKey: DefaultModelKey,
  overrides?: Partial<Omit<ModelConfig, "provider">>
): ModelConfig
⋮----
// Create a new object to avoid modifying the default
⋮----
// Apply any overrides
⋮----
/**
 * Helper function to configure function calling for Vertex AI models
 *
 * @param mode - Function calling mode (AUTO, NONE, or ANY)
 * @param allowedFunctionNames - Optional list of allowed function names
 * @returns FunctionCallingConfig object
 */
export function createFunctionCallingConfig(
  mode: "AUTO" | "NONE" | "ANY" = "AUTO",
  allowedFunctionNames: string[] = []
): FunctionCallingConfig
⋮----
/**
 * Standard response validation options
 */
⋮----
/**
 * Standard error handler function for agents
 */
export const defaultErrorHandler = async (
  error: Error
): Promise<Record<string, unknown>> =>
⋮----
export type BaseAgentConfigType = BaseAgentConfig;
````

## File: src/mastra/agents/config/model.utils.ts
````typescript
/**
 * Model Utility Functions
 *
 * This module provides utility functions for creating AI model instances
 * based on configuration settings, supporting multiple providers.
 *
 * @module model.utils
 */
⋮----
import { google } from "@ai-sdk/google";
import { vertex } from "@ai-sdk/google-vertex";
import { ModelConfig, ModelProvider } from "./config.types";
⋮----
/**
 * Model creation options
 */
export interface ModelCreationOptions {
  /** Project ID for Vertex AI */
  vertexProjectId?: string;

  /** Location for Vertex AI */
  vertexLocation?: string;

  /** Google API key */
  googleApiKey?: string;
}
⋮----
/** Project ID for Vertex AI */
⋮----
/** Location for Vertex AI */
⋮----
/** Google API key */
⋮----
/**
 * Creates a model instance based on the provided configuration
 *
 * @param modelConfig - Configuration for the model
 * @param options - Additional options for model creation
 * @returns A model instance compatible with @mastra/core/agent
 * @throws {Error} If the model provider is unsupported or configuration is invalid
 */
export function createModelFromConfig(
  modelConfig: ModelConfig,
  options: ModelCreationOptions = {}
): ReturnType<typeof google> | ReturnType<typeof vertex>
⋮----
// Create and return Google model instance using the @ai-sdk/google format
⋮----
// Create and return Vertex model instance
⋮----
/**
 * Creates a Google AI model instance with default settings
 *
 * @param modelId - Model ID to use
 * @param apiKey - Optional Google API key (otherwise uses environment variable)
 * @param options - Additional model options
 * @returns A Google AI model instance
 */
export function createGoogleModel(
  modelId: string,
  apiKey?: string,
  options?: Record<string, unknown>
): ReturnType<typeof google>
⋮----
/**
 * Creates a Google Vertex AI model instance with default settings
 *
 * @param modelId - Model ID to use
 * @param projectId - Optional Vertex project ID (otherwise uses GOOGLE_VERTEX_PROJECT env var)
 * @param location - Optional Vertex location (otherwise uses GOOGLE_VERTEX_LOCATION env var or default)
 * @param options - Additional model options
 * @returns A Google Vertex AI model instance
 */
export function createVertexModel(
  modelId: string,
  projectId?: string,
  location?: string,
  options?: Record<string, unknown>
): ReturnType<typeof vertex>
⋮----
/**
 * Creates a model instance based on the model configuration
 * This is an alias for createModelFromConfig with a more concise name
 *
 * @param config - Model configuration
 * @param options - Optional creation options
 * @returns A model instance for the specified provider
 */
export function createModelInstance(
  config: ModelConfig,
  options: ModelCreationOptions = {}
): ReturnType<typeof google> | ReturnType<typeof vertex>
````

## File: src/mastra/agents/config/provider.utils.ts
````typescript
/**
 * Model Provider Utilities
 *
 * This module provides utilities for setting up and configuring AI model providers.
 * It handles provider client setup and credential management, but NOT model instantiation.
 *
 * @module provider.utils
 */
⋮----
import { google } from "@ai-sdk/google";
import { createVertex } from "@ai-sdk/google-vertex";
import { env } from "process";
import { util } from "zod";
⋮----
/** Supported model providers */
export type ModelProvider = "google" | "vertex";
⋮----
/** Options for configuring the Google AI provider setup */
export type GoogleOptions = Partial<Pick<GoogleProviderConfig, 'apiKey'>>;
⋮----
/** Options for configuring the Google Vertex AI provider setup */
export type GoogleVertexOptions = Partial<Pick<VertexProviderConfig, 'projectId' | 'location'>>;
⋮----
/** Union type for all provider setup options */
export type ProviderSetupOptions = GoogleOptions | GoogleVertexOptions;
⋮----
/**
 * Configuration for Google AI provider
 */
export interface GoogleProviderConfig {
  /** API Key for Google AI */
  apiKey: string;
}
⋮----
/** API Key for Google AI */
⋮----
/**
 * Configuration for Google Vertex AI provider
 */
export interface VertexProviderConfig {
  /** Project ID for Vertex AI */
  projectId: string;
  /** Location for Vertex AI */
  location: string;
  /** Credentials for Vertex AI */
  credentials: Record<string, unknown>;
}
⋮----
/** Project ID for Vertex AI */
⋮----
/** Location for Vertex AI */
⋮----
/** Credentials for Vertex AI */
⋮----
/**
 * Generic provider configuration type
 */
export type ProviderConfig = GoogleProviderConfig | VertexProviderConfig;
⋮----
/**
 * Sets up the Google AI provider configuration
 *
 * @param options - Google AI specific options
 * @returns Google AI provider configuration
 * @throws {Error} If API key is not provided and not available in environment
 */
export function setupGoogleProvider(
  options?: GoogleOptions
): GoogleProviderConfig
⋮----
// Use API key from options, environment variable, or throw error
⋮----
/**
 * Creates a Google AI client configuration object
 *
 * @param config - Google provider configuration
 * @param config - Google provider configuration (contains validated apiKey)
 * @returns Google AI client configuration for @ai-sdk/google
 */
export function createGoogleClientConfig(
  // config parameter is currently unused as the SDK reads the API key from the environment.
  // It's kept for potential future configuration options.
  config: GoogleProviderConfig
): Parameters<typeof google>[1]
⋮----
// config parameter is currently unused as the SDK reads the API key from the environment.
// It's kept for potential future configuration options.
⋮----
// The @ai-sdk/google provider automatically uses the
// GOOGLE_GENERATIVE_AI_API_KEY environment variable.
// The config object passed here is for other settings (e.g., baseURL, headers).
// setupGoogleProvider ensures the API key exists in the environment or options.
⋮----
/**
 * Sets up the Google Vertex AI provider configuration
 *
 * @param options - Vertex AI specific options
 * @returns Vertex AI provider configuration
 * @throws {Error} If required environment variables are not available
 */
export function setupVertexProvider(
  options?: GoogleVertexOptions
): VertexProviderConfig
⋮----
// Get project ID from options or environment
⋮----
// Get location from options or environment
⋮----
// Use service account credentials from environment if available
⋮----
// For direct usage without a JSON file, we may need just the key parts
// or rely on application default credentials when deployed
⋮----
/**
 * Creates a Vertex AI client configuration
 *
 * @param config - Vertex provider configuration
 * @returns Vertex AI client configuration for @ai-sdk/google-vertex
 */
export function createVertexClientConfig(
  config: VertexProviderConfig
): ReturnType<typeof createVertex>
⋮----
// Credentials are often handled via environment variables (GOOGLE_APPLICATION_CREDENTIALS)
// or Application Default Credentials (ADC) when running on GCP.
// Explicitly passing credentials here might be needed in specific scenarios.
// If config.credentials contains the necessary structure, pass it here.
// Example (if credentials are a service account key object):
// credentials: config.credentials,
⋮----
/**
 * Gets the appropriate provider configuration based on provider type
 *
 * @param provider - The model provider to configure
 * @param options - Provider-specific options
 * @returns Provider configuration object
 * @throws {Error} If provider is unsupported
 */
export function getProviderConfig(
  provider: ModelProvider,
  options?: Record<string, unknown>
): ProviderConfig
````

## File: src/mastra/agents/copywriter.agent.ts
````typescript
/**
 * Copywriter Agent Implementation
 *
 * This module implements the Copywriter Agent responsible for creating
 * marketing copy and content within the DeanmachinesAI system.
 */
⋮----
import { Agent } from "@mastra/core/agent";
import { createAgentFromConfig } from "./base.agent";
import {copywriterAgentConfig }from "./config";
import { createLogger } from "@mastra/core/logger";
import { sharedMemory } from "../database";
⋮----
// Configure logger for the copywriter agent
⋮----
/**
 * Initialize the copywriter agent instance using its configuration
 *
 * @returns The initialized copywriter agent instance
 */
export function initializeCopywriterAgent(): Agent
⋮----
memory: sharedMemory, // Following RULE-MemoryInjection
⋮----
/**
 * Singleton instance of the copywriter agent
 */
````

## File: src/mastra/database/vector-store.ts
````typescript
/**
 * Vector store configuration for document embedding and retrieval.
 *
 * This module configures Pinecone as the primary vector database for
 * semantic search and RAG functionality with fallback to Upstash.
 */
⋮----
import { PineconeStore } from "@langchain/pinecone";
import { GoogleGenerativeAIEmbeddings } from "@langchain/google-genai";
import { env } from "process";
import { Pinecone } from "@pinecone-database/pinecone";
import { EmbeddingModelV1, EmbeddingModelV1Embedding } from "@ai-sdk/provider";
⋮----
/**
 * Adapter class that extends GoogleGenerativeAIEmbeddings to implement the EmbeddingModelV1 interface
 * required by Mastra's Memory system.
 */
export class MastraEmbeddingAdapter
extends GoogleGenerativeAIEmbeddings
⋮----
/**
   * Version of the embedding specification
   */
⋮----
/**
   * Provider of the embedding model
   */
⋮----
/**
   * ID of the embedding model being used
   */
⋮----
/**
   * Maximum number of embeddings allowed per API call
   */
⋮----
/**
   * Maximum input token length for the model
   */
⋮----
/**
   * Dimensionality of the embedding vectors
   */
⋮----
/**
   * Creates a new Mastra embedding adapter
   *
   * @param options - Configuration options for the embeddings model
   */
constructor(options: {
    apiKey?: string;
    modelName?: string;
    maxEmbeddingsPerCall?: number;
    dimensions?: number;
})
⋮----
// Assume false by default unless underlying implementation confirms otherwise
⋮----
doEmbed(options: { values: string[]; abortSignal?: AbortSignal; headers?: Record<string, string | undefined>; }): PromiseLike<{ embeddings: Array<EmbeddingModelV1Embedding>; usage? /** Pinecone environment (e.g., 'us-east-1') */: { tokens: number; }; rawResponse?: { headers?: Record<string, string>; }; }> {
⋮----
/**
 * Configuration for Pinecone vector store
 */
export interface PineconeConfig {
  /** Pinecone API key from environment */
  apiKey: string;
  /** Pinecone environment (e.g., 'us-east-1') */
  environment: string;
  /** Pinecone index name */
  index: string;
  /** Optional namespace for organization */
  namespace?: string;
  /** Dimension size for embeddings */
  dimension?: number;
  /** Distance metric for similarity search */
  metric?: "cosine" | "euclidean" | "dotproduct";
}
⋮----
/** Pinecone API key from environment */
⋮----
/** Pinecone environment (e.g., 'us-east-1') */
⋮----
/** Pinecone index name */
⋮----
/** Optional namespace for organization */
⋮----
/** Dimension size for embeddings */
⋮----
/** Distance metric for similarity search */
⋮----
/**
 * Creates and initializes a Pinecone vector store
 *
 * @param embeddings - GoogleGenerativeAIEmbeddings instance for embedding generation
 * @param config - Pinecone configuration options
 * @returns An initialized PineconeStore instance
 * @throws If Pinecone client initialization fails
 */
export async function createPineconeVectorStore(
  embeddings: GoogleGenerativeAIEmbeddings | MastraEmbeddingAdapter,
  config?: Partial<PineconeConfig>
)
⋮----
// Validate environment variables and configuration
⋮----
// Initialize Pinecone client
⋮----
/**
 * Creates and initializes embeddings model for vector storage
 *
 * @param apiKey - Google API key for generating embeddings
 * @param modelName - Name of the embedding model to use
 * @returns MastraEmbeddingAdapter instance that implements all required interface properties
 */
export function createEmbeddings(
  apiKey?: string,
  modelName?: string
): MastraEmbeddingAdapter
⋮----
/**
 * Creates a vector store backup using Upstash
 * Uses Upstash as a fallback if Pinecone is unavailable
 *
 * @param embeddings - Embeddings to use with Upstash
 * @returns Upstash vector store instance or undefined if not configured
 */
export function createUpstashBackup(embeddings: MastraEmbeddingAdapter)
⋮----
// Note: The Upstash integration would need actual implementation
// based on the specific Upstash client for Mastra
⋮----
return undefined; // Replace with actual implementation when needed
````

## File: src/mastra/services/exasearch.ts
````typescript
/**
 * Exa Search service for Mastra AI.
 *
 * Provides utility functions to integrate Exa search capabilities
 * with Mastra agents and workflows.
 */
⋮----
import Exa from "exa-js";
import { env } from "process";
⋮----
/**
 * Configuration options for Exa search
 */
export interface ExaSearchConfig {
  /** API key for Exa (defaults to environment variable) */
  apiKey?: string;
  /** Number of search results to return */
  numResults?: number;
  /** Whether to use highlights in search results */
  useHighlights?: boolean;
  /** Whether to include query in search results */
  includeQuery?: boolean;
  /** Whether to include raw content in search results */
  includeRawContent?: boolean;
}
⋮----
/** API key for Exa (defaults to environment variable) */
⋮----
/** Number of search results to return */
⋮----
/** Whether to use highlights in search results */
⋮----
/** Whether to include query in search results */
⋮----
/** Whether to include raw content in search results */
⋮----
/**
 * Search result from Exa
 */
export interface ExaSearchResult {
  /** Title of the search result */
  title: string;
  /** URL of the search result */
  url: string;
  /** Text content of the search result */
  text: string;
  /** Highlighted text snippets (if enabled) */
  highlights?: string[];
  /** Score/relevance of the result */
  score?: number;
  /** Published date of the content (if available) */
  published?: string;
}
⋮----
/** Title of the search result */
⋮----
/** URL of the search result */
⋮----
/** Text content of the search result */
⋮----
/** Highlighted text snippets (if enabled) */
⋮----
/** Score/relevance of the result */
⋮----
/** Published date of the content (if available) */
⋮----
/**
 * Creates an Exa client with the provided configuration
 *
 * @param config - Configuration options for Exa
 * @returns An initialized Exa client
 */
export function createExaClient(config: ExaSearchConfig =
⋮----
/**
 * Performs a web search using Exa
 *
 * @param query - The search query
 * @param config - Configuration options for the search
 * @returns Array of search results
 */
export async function searchWeb(
  query: string,
  config: ExaSearchConfig = {}
): Promise<ExaSearchResult[]>
⋮----
// Use the correct method signature for search based on exa-js documentation
⋮----
// The useHighlights property is not supported in RegularSearchOptions
⋮----
// Get content for each result
⋮----
// Use getContents with the correct parameter (ID from the result)
⋮----
highlights: [], // Exa SearchResult type doesn't include highlights
⋮----
highlights: [], // Exa SearchResult type doesn't include highlights
⋮----
/**
 * Performs a search with specific filters using Exa
 *
 * @param query - The search query
 * @param filters - Filters to apply to the search (e.g., site, date)
 * @param config - Configuration options for the search
 * @returns Array of search results
 */
export async function searchWithFilters(
  query: string,
  filters: {
    site?: string;
    startDate?: string;
    endDate?: string;
    recentOnly?: boolean;
  },
  config: ExaSearchConfig = {}
): Promise<ExaSearchResult[]>
⋮----
// Set up search parameters
⋮----
// The useHighlights property is not supported in RegularSearchOptions
⋮----
// Add filters if provided
⋮----
// If recentOnly is true, set startPublishedDate to 30 days ago if not already set
⋮----
// Use the correct method signature for search
⋮----
// Get content for each result
⋮----
// Use getContents with the correct parameter (ID from the result)
⋮----
highlights: [], // Exa SearchResult type doesn't include highlights
⋮----
/**
 * Performs a search and returns results formatted for RAG (Retrieval Augmented Generation)
 *
 * @param query - The search query
 * @param config - Configuration options for the search
 * @returns Formatted text for RAG
 */
export async function searchForRAG(
  query: string,
  config: ExaSearchConfig = {}
): Promise<string>
⋮----
// Format results for RAG
⋮----
// If no highlights but we have text, use a snippet
⋮----
/**
 * Example function showing how to use the Exa search service
 *
 * @param query - The search query
 * @returns Formatted search results
 */
export async function exampleSearch(query: string): Promise<string>
⋮----
// Basic search
⋮----
// Filtered search (last 30 days)
⋮----
// RAG-formatted results
````

## File: src/mastra/services/langfuse.ts
````typescript
import { z } from "zod";
import { Langfuse } from "langfuse";
import { createLogger } from "@mastra/core/logger";
import { env } from "process";
⋮----
/**
 * Langfuse Integration Service
 *
 * This module provides integration with Langfuse for observability and analytics
 * in Mastra agents. It enables tracing, scoring, and monitoring of LLM operations
 * to improve reliability and performance tracking.
 */
⋮----
// Configure logger for Langfuse service
⋮----
/**
 * Environment validation schema for Langfuse
 */
⋮----
/**
 * Validate environment configuration for Langfuse
 *
 * @returns Validated environment configuration
 * @throws {Error} If validation fails (missing API keys)
 */
function validateEnv()
⋮----
// Validate environment at module load time
⋮----
/**
 * Create a Langfuse client instance
 *
 * @throws {Error} If creation fails due to invalid configuration
 */
function createLangfuseClient()
⋮----
// Initialize Langfuse client once
⋮----
/**
 * Langfuse service for observability and analytics
 */
export class LangfuseService {
⋮----
constructor()
⋮----
/**
   * Create a new trace to track a user session or request
   *
   * @param name - Name of the trace
   * @param options - Additional options for the trace
   * @returns Trace object
   */
createTrace(name: string, options?: {
    userId?: string;
    metadata?: Record<string, unknown>;
    tags?: string[];
})
⋮----
/**
   * Log a span within a trace to measure a specific operation
   *
   * @param name - Name of the span
   * @param options - Configuration options for the span
   * @returns Span object
   */
createSpan(name: string, options: {
    traceId: string;
    parentSpanId?: string;
    input?: unknown;
    metadata?: Record<string, unknown>;
    tags?: string[];
})
⋮----
/**
   * Log a generation event (e.g., LLM call)
   *
   * @param name - Name of the generation
   * @param options - Configuration options for the generation
   * @returns Generation object
   */
logGeneration(name: string, options: {
    traceId: string;
    input: unknown;
    output?: unknown;
    promptTokens?: number;
    completionTokens?: number;
    model?: string;
    metadata?: Record<string, unknown>;
    tags?: string[];
})
⋮----
/**
   * Score a trace, span, or generation for quality evaluation
   *
   * @param options - Configuration options for the score
   * @returns Score object
   * @throws {Error} If no target ID (traceId, spanId, or generationId) is provided
   */
createScore(options: {
    name: string;
    value: number;
    traceId?: string;
    spanId?: string;
    generationId?: string;
    comment?: string;
})
⋮----
// Ensure at least one of traceId, spanId, or generationId is provided
⋮----
// TypeScript type assertion to satisfy the compiler
⋮----
/**
   * Flush all pending Langfuse events
   *
   * @returns Promise that resolves when all events have been flushed
   */
async flush(): Promise<void>
⋮----
// Export a singleton instance for use throughout the application
````

## File: src/mastra/tools/calculator.ts
````typescript
import { createTool } from "@mastra/core/tools";
import { z } from "zod";
import { calculator } from "@agentic/calculator";
⋮----
/**
 * Configuration for the calculator tool.
 *
 * @interface CalculatorConfig
 */
export interface CalculatorConfig {
  maxRetries?: number;
  timeout?: number;
}
⋮----
/**
 * Creates a configured calculator client.
 *
 * @param _config Calculator configuration options.
 * @returns A tool instance that performs mathematical calculations.
 * @throws {Error} If the calculation fails.
 */
export function createCalculatorTool(_config: CalculatorConfig =
⋮----
// Use the validated input from context
⋮----
steps: [], // Calculator doesn't return steps
````

## File: src/mastra/tools/google-search.ts
````typescript
import { createTool } from "@mastra/core/tools";
import { z } from "zod";
import { GoogleCustomSearchClient } from "@agentic/google-custom-search"; // Fixed: correct client name
import { env } from "process";
⋮----
/**
 * Configuration for Google Custom Search
 */
interface GoogleSearchConfig {
  apiKey?: string;
  searchEngineId?: string;
  maxResults?: number;
  timeout?: number;
}
⋮----
/**
 * Creates a configured Google Custom Search tool
 */
export function createGoogleSearchTool(config: GoogleSearchConfig =
⋮----
cseId: config.searchEngineId ?? env.GOOGLE_CSE_ID, // Fixed: property name is cseId
⋮----
// Updated to match correct search parameters - search method expects only query
// Options like num and safe might need to be handled post-retrieval or
// might not be directly supported by this client's search method signature.
⋮----
// Manually limit results if maxResults is provided
⋮----
// Note: Safe search filtering needs to be configured in the CSE control panel
// or handled by filtering results if the API/client doesn't support it directly.
````

## File: src/mastra/tools/llmchain.ts
````typescript
/**
 * LLM Chain Tool for Mastra AI.
 *
 * This module provides tools for creating and running language model chains
 * using AI SDK and other providers, with integration to Mastra's agent ecosystem.
 *
 * @module LLMChainTool
 */
⋮----
import { createTool } from "@mastra/core/tools";
import { z } from "zod";
import { openai } from "@ai-sdk/openai";
import { google } from "@ai-sdk/google";
import { anthropic } from "@ai-sdk/anthropic";
import { createLLMChain } from "../services/langchain";
import { createLangSmithRun, trackFeedback } from "../services/langsmith";
import { env } from "process";
⋮----
import { createLogger } from "@mastra/core/logger";
⋮----
/**
 * Provider options for the LLM chain
 */
export type LLMProvider = "openai" | "google" | "anthropic";
⋮----
/**
 * LLM Configuration options
 */
export interface LLMChainConfig {
  /** The model provider to use */
  provider?: LLMProvider;
  /** Specific model name to use */
  modelName?: string;
  /** Temperature setting for model responses (0-1) */
  temperature?: number;
  /** Maximum number of tokens in response */
  maxTokens?: number;
  /** Whether to enable LangSmith tracing */
  enableTracing?: boolean;
  /** Whether to use LangChain for processing */
}
⋮----
/** The model provider to use */
⋮----
/** Specific model name to use */
⋮----
/** Temperature setting for model responses (0-1) */
⋮----
/** Maximum number of tokens in response */
⋮----
/** Whether to enable LangSmith tracing */
⋮----
/** Whether to use LangChain for processing */
⋮----
/**
 * Creates an AI SDK model instance based on provider
 *
 * @param config - Configuration options for the AI SDK model
 * @returns A configured AI SDK model instance that supports both completion and chat interfaces
 * @throws {Error} When an unsupported provider is specified or when required API keys are missing
 */
/**
 * Creates an AI SDK model instance based on provider
 *
 * @param config - Configuration options for the AI SDK model
 * @returns A configured AI SDK model instance that supports both completion and chat interfaces
 * @throws {Error} When an unsupported provider is specified or when required API keys are missing
 */
function createAiSdkModel(config: LLMChainConfig =
⋮----
// Create model based on provider
⋮----
/**
 * Tool for executing an LLM chain with a prompt template
 */
⋮----
const startTime = Date.now(); // Create run for LangSmith tracing
⋮----
// Extract variables from context
⋮----
// Configure LLM
⋮----
// Execute chain based on selected implementation
⋮----
// Use LangChain implementation
⋮----
// Use AI SDK implementation
⋮----
// Replace template variables manually
⋮----
// Handle different providers with appropriate API calls
⋮----
// Type assertion to access the chat method for OpenAI - using double casting for safety
⋮----
// Type assertion to access the messages method for Anthropic
⋮----
// Google implementation
// Type assertion to access the generateContent method for Google
⋮----
// Track success in LangSmith
⋮----
// Return successful result
⋮----
// Track failure in LangSmith
⋮----
// Return error result
⋮----
/**
 * Tool for executing a structured prompt with the AI SDK
 */
⋮----
const startTime = Date.now(); // Create run for LangSmith tracing
⋮----
// Extract variables from context
⋮----
// Configure LLM
⋮----
// Create model
const model = createAiSdkModel(llmConfig); // Prepare messages
⋮----
// Add system prompt if provided
⋮----
// Add history if provided
⋮----
// Add the current prompt
⋮----
// Handle different providers
⋮----
// OpenAI implementation with thread and resource management
⋮----
// Add threadId if provided for conversation history
⋮----
// Add resourceId if provided for observability
⋮----
// Add schema for structured output if provided
⋮----
// Make API call with options
⋮----
// Extract structured output from OpenAI tool calls
⋮----
// Anthropic implementation with proper thread management
⋮----
// Add threadId if provided to maintain conversation context
⋮----
// Add resourceId if provided for observability
⋮----
// Handle structured output via tool calling
⋮----
// Type assertion to access the messages method for Anthropic
⋮----
// Extract structured output properly based on Claude's format
⋮----
// Type assertion to access the messages method for Anthropic
⋮----
// Google implementation with thread and resource management
⋮----
// Add threadId for conversation history management if provided
⋮----
// Add resource tracking metadata if provided
⋮----
// Add schema for structured output if provided
⋮----
// Make API call with proper options
⋮----
// Extract structured output from tool calls for Google
⋮----
// Find function call in the parts
interface FunctionCallPart {
            functionCall?: {
              name: string;
              args: string;
            };
            text?: string;
          }
⋮----
// Track success in LangSmith
⋮----
// Return successful result
⋮----
// Track failure in LangSmith
⋮----
// Return error result
````

## File: src/mastra/tools/rlFeedback.ts
````typescript
/**
 * Reinforcement Learning Feedback Tools for Mastra AI.
 *
 * This module provides tools for collecting, analyzing, and applying
 * feedback for reinforcement learning to improve agent performance over time.
 */
⋮----
import { createTool } from "@mastra/core/tools";
import { z } from "zod";
import { LibSQLStore } from "@mastra/core/storage/libsql";
import { GoogleGenerativeAI } from "@google/generative-ai";
import { createLangSmithRun, trackFeedback } from "../services/langsmith";
import { Memory } from "@mastra/memory";
⋮----
// Helper function to get environment variable with fallback
const getEnvVar = (name: string, fallback: string = ''): string =>
⋮----
// Create a storage instance
const getStorage = (): LibSQLStore =>
⋮----
// For development, use in-memory database if env variables aren't set
⋮----
// Fallback to in-memory database
⋮----
// Initialize a Memory instance for storing RL feedback data
⋮----
/**
 * Types of feedback that can be collected for RL
 */
export enum FeedbackType {
  /** User explicitly rates agent response */
  EXPLICIT = "explicit",
  /** System infers quality from user behavior */
  IMPLICIT = "implicit",
  /** Model evaluates its own performance */
  SELF_CRITIQUE = "self_critique",
}
⋮----
/** User explicitly rates agent response */
⋮----
/** System infers quality from user behavior */
⋮----
/** Model evaluates its own performance */
⋮----
/**
 * Feedback metrics that can be tracked
 */
export interface FeedbackMetrics {
  /** Overall quality score (1-10) */
  quality: number;
  /** Accuracy of information (1-10) */
  accuracy?: number;
  /** Relevance to user request (1-10) */
  relevance?: number;
  /** Helpfulness of the response (1-10) */
  helpfulness?: number;
  /** Time taken to respond (ms) */
  latencyMs?: number;
  /** Free-form comment about the response */
  comment?: string;
}
⋮----
/** Overall quality score (1-10) */
⋮----
/** Accuracy of information (1-10) */
⋮----
/** Relevance to user request (1-10) */
⋮----
/** Helpfulness of the response (1-10) */
⋮----
/** Time taken to respond (ms) */
⋮----
/** Free-form comment about the response */
⋮----
/**
 * Tool for collecting feedback on agent responses
 */
⋮----
// Generate a unique ID for this feedback
⋮----
// Instead of using the LibSQLStore directly, use Memory API to store feedback
// First, create or get an existing thread for the agent's RL feedback
⋮----
// Thread doesn't exist yet, create it
⋮----
// Format the feedback data as a system message
⋮----
// Add a message to the thread with the feedback content
// Include metadata in the content as the addMessage method doesn't support metadata directly
⋮----
role: "assistant", // Changed from "system" to "assistant" as Mastra only supports "user" or "assistant"
⋮----
// Track in LangSmith as well if available
⋮----
score: context.feedback.metrics.quality / 10, // Normalize to 0-1
⋮----
// Track failure in LangSmith
⋮----
/**
 * Tool for analyzing collected feedback to derive insights
 */
⋮----
// Get memory adapter for retrieving feedback
⋮----
// Query parameters for feedback retrieval
⋮----
// Retrieve feedback for analysis
// Note: In a real implementation, you would query by date range and agent ID
// This is a simplified version that would need to be adapted to your specific
// LibSQLStore implementation details
⋮----
// For demonstration, we'll generate sample feedback data
⋮----
// Use LLM to generate insights from feedback data
⋮----
// Aggregate metrics
⋮----
// Generate insights using LLM
⋮----
// Extract JSON from the response
⋮----
// Track success in LangSmith
⋮----
// Track failure in LangSmith
⋮----
/**
 * Tool for applying RL insights to improve agent performance
 */
⋮----
// Use LLM to generate improved instructions based on insights
⋮----
// Generate summary of changes
⋮----
// Extract JSON from the response
⋮----
// Track success in LangSmith
⋮----
// Track failure in LangSmith
⋮----
/**
 * Helper function to generate sample feedback data for testing
 *
 * @param agentId - ID of the agent
 * @param startDate - Start date for generated data
 * @param endDate - End date for generated data
 * @param count - Number of feedback entries to generate
 * @returns Array of simulated feedback entries
 */
function generateSampleFeedback(
  agentId: string,
  startDate: Date,
  endDate: Date,
  count: number
): Array<
⋮----
// Sort by timestamp
⋮----
/**
 * Aggregate metrics from feedback entries
 *
 * @param feedback - Array of feedback entries
 * @returns Aggregated metrics
 */
function aggregateMetrics(
  feedback: Array<{
    metrics: FeedbackMetrics;
    timestamp: string;
  }>
): Array<
⋮----
// Initialize result structure with known metrics
⋮----
// Aggregate data
⋮----
// Skip non-numeric metrics
⋮----
// Initialize metric if not exists
⋮----
// Calculate averages and format result
⋮----
/**
 * Determine trend from a series of values
 *
 * @param values - Array of values with timestamps
 * @returns Trend description ("improving", "declining", "stable")
 */
function determineTrend(
  values: Array<{
    value: number;
    timestamp: string;
  }>
): string
⋮----
// Need at least 2 values to determine trend
⋮----
// Sort by timestamp
⋮----
// Split into two halves to compare
⋮----
// Calculate averages
⋮----
// Determine trend
````

## File: src/mastra/tools/rlReward.ts
````typescript
/**
 * Reinforcement Learning Reward Function Tools for Mastra AI.
 *
 * This module provides tools for defining, managing, and optimizing RL reward functions
 * to guide agent learning through numerical feedback on actions taken in different states.
 */
⋮----
import { createTool } from "@mastra/core/tools";
import { z } from "zod";
import { LibSQLStore } from "@mastra/core/storage/libsql";
import { GoogleGenerativeAI } from "@google/generative-ai";
import { createLangSmithRun, trackFeedback } from "../services/langsmith";
import { Memory } from "@mastra/memory";
import { env } from "process";
⋮----
// Helper function to get environment variable with fallback
const getEnvVar = (name: string, fallback: string = ''): string =>
⋮----
// Create a storage instance
const getStorage = (): LibSQLStore =>
⋮----
// For development, use in-memory database if env variables aren't set
⋮----
// Fallback to in-memory database
⋮----
// Initialize a Memory instance for storing RL reward data
⋮----
/**
 * Represents a state-action pair in reinforcement learning
 */
export interface StateAction {
  /** Current state representation (can be any serializable data) */
  state: Record<string, unknown>;
  /** Action taken by the agent */
  action: string;
  /** Additional context about the action (optional) */
  context?: Record<string, unknown>;
}
⋮----
/** Current state representation (can be any serializable data) */
⋮----
/** Action taken by the agent */
⋮----
/** Additional context about the action (optional) */
⋮----
/**
 * Types of reward signals that can be used
 */
export enum RewardType {
  /** Simple scalar reward (number) */
  SCALAR = "scalar",
  /** Vector reward (multiple dimensions) */
  VECTOR = "vector",
  /** Binary reward (success/failure) */
  BINARY = "binary",
  /** Human feedback reward */
  HUMAN = "human",
}
⋮----
/** Simple scalar reward (number) */
⋮----
/** Vector reward (multiple dimensions) */
⋮----
/** Binary reward (success/failure) */
⋮----
/** Human feedback reward */
⋮----
/**
 * Configuration for a reward function
 */
export interface RewardFunctionConfig {
  /** Unique identifier for this reward function */
  id: string;
  /** Human-readable name */
  name: string;
  /** Functional description */
  description: string;
  /** Type of rewards provided */
  rewardType: RewardType;
  /** Whether to normalize rewards to [-1,1] range */
  normalize?: boolean;
  /** Discount factor for future rewards (gamma) */
  discountFactor?: number;
  /** Weight for this reward if combined with others */
  weight?: number;
}
⋮----
/** Unique identifier for this reward function */
⋮----
/** Human-readable name */
⋮----
/** Functional description */
⋮----
/** Type of rewards provided */
⋮----
/** Whether to normalize rewards to [-1,1] range */
⋮----
/** Discount factor for future rewards (gamma) */
⋮----
/** Weight for this reward if combined with others */
⋮----
/**
 * Reward tracking data structure
 */
export interface RewardRecord {
  /** Timestamp when the reward was recorded */
  timestamp: string;
  /** Agent that received the reward */
  agentId: string;
  /** Episode or interaction identifier */
  episodeId: string;
  /** State-action pair that led to this reward */
  stateAction: StateAction;
  /** Numerical reward value */
  reward: number;
  /** Cumulative reward for the episode so far */
  cumulativeReward: number;
  /** Step number within the episode */
  stepNumber: number;
  /** Whether this is a terminal reward (end of episode) */
  isTerminal: boolean;
  /** Additional metadata */
  metadata?: Record<string, unknown>;
}
⋮----
/** Timestamp when the reward was recorded */
⋮----
/** Agent that received the reward */
⋮----
/** Episode or interaction identifier */
⋮----
/** State-action pair that led to this reward */
⋮----
/** Numerical reward value */
⋮----
/** Cumulative reward for the episode so far */
⋮----
/** Step number within the episode */
⋮----
/** Whether this is a terminal reward (end of episode) */
⋮----
/** Additional metadata */
⋮----
/**
 * Tool for calculating rewards based on state-action pairs
 */
⋮----
// Create the state-action pair
⋮----
// Calculate the reward based on the state-action pair
⋮----
// Generate a unique ID for this reward record
⋮----
// Get previous cumulative reward by querying the episode thread
⋮----
// Try to get existing thread for this episode
⋮----
// If thread exists, get previous messages and calculate cumulative reward
⋮----
selectBy: { last: 1 } // Get most recent message
⋮----
// Parse the content which should contain the RewardRecord
⋮----
// Continue with just the current reward
⋮----
// Create the reward record
⋮----
// Create or get thread for this episode
⋮----
// Thread doesn't exist yet, create it
⋮----
// Store the reward record as a message in the thread
// Include metadata in the content as the addMessage method doesn't support metadata directly
⋮----
// Track in LangSmith for observability
⋮----
// Track failure in LangSmith
⋮----
/**
 * Tool for defining custom reinforcement learning reward functions
 */
⋮----
// Create the reward function configuration
⋮----
// Generate a unique thread ID for storing reward functions
⋮----
// Create or get thread for reward functions
⋮----
// Thread doesn't exist yet, create it
⋮----
// Store the reward function definition as a message
⋮----
// Include metadata in the content as the addMessage method doesn't support metadata directly
⋮----
// Track in LangSmith
⋮----
// Track failure in LangSmith
⋮----
/**
 * Tool for analyzing reinforcement learning rewards and optimizing policies
 */
⋮----
// Get memory adapter for retrieving reward data
⋮----
// Query parameters
⋮----
// Retrieve reward records for the specified agent and time period
// Note: This is a simplified implementation - in practice, you would need to
// implement a query mechanism for LibSQLStore that supports filtering by agent, date, etc.
⋮----
// Use LLM to analyze rewards and suggest policy improvements
⋮----
// Prepare reward data summary for analysis
⋮----
// Generate policy improvements
⋮----
// Extract JSON from the response
⋮----
// Track success in LangSmith
⋮----
// Track failure in LangSmith
⋮----
/**
 * Calculates reward for a given state-action pair
 *
 * @param stateAction - The state-action pair to evaluate
 * @param rewardFunctionId - Optional specific reward function to use
 * @returns Reward value and breakdown
 */
async function calculateStateActionReward(
  stateAction: StateAction,
  rewardFunctionId?: string
): Promise<
⋮----
// This is a simplified implementation - in a real system you would:
// 1. Retrieve the specific reward function from the database
// 2. Apply the function's formula to the state-action pair
// 3. Return the calculated reward
⋮----
// For demonstration, we'll implement a simple reward calculation
⋮----
// Example reward calculation - adapt this to your specific use case
⋮----
// Example component: task completion reward
⋮----
// Example component: efficiency reward (negative for high latency)
⋮----
const efficiencyReward = Math.max(-5, -latency / 1000); // Cap at -5
⋮----
// Example component: accuracy reward
⋮----
const accuracyReward = accuracy * 5; // Scale 0-1 accuracy to 0-5 reward
⋮----
// Default small reward for taking any action (encourages exploration)
⋮----
return { reward: 0 }; // Default to zero reward on error
⋮----
/**
 * Normalizes a reward value to the range [-1, 1]
 *
 * @param reward - Raw reward value
 * @returns Normalized reward in range [-1, 1]
 */
function normalizeReward(reward: number): number
⋮----
// Simple normalization using tanh
⋮----
/**
 * Retrieves previous rewards for a specific agent and episode
 *
 * @param storage - Storage adapter for reward data
 * @param agentId - ID of the agent
 * @param episodeId - ID of the episode
 * @returns Array of reward records, or undefined if none found
 */
async function retrievePreviousRewards(
  storage: LibSQLStore,
  agentId: string,
  episodeId: string
): Promise<RewardRecord[] | undefined>
⋮----
// This is a simplified placeholder - in a real implementation you would:
// 1. Query the database for rewards matching the agent and episode IDs
// 2. Sort and return the results
⋮----
// For demonstration purposes, we return an empty array
// Replace this with actual database query logic
⋮----
/**
 * Retrieves reward records for an agent within a time period
 *
 * @param storage - Storage adapter for reward data
 * @param agentId - ID of the agent
 * @param episodeIds - Optional specific episodes to include
 * @param startDate - Start of the time period
 * @param endDate - End of the time period
 * @returns Array of reward records
 */
async function retrieveAgentRewards(
  storage: LibSQLStore,
  agentId: string,
  episodeIds?: string[],
  startDate?: Date,
  endDate?: Date
): Promise<RewardRecord[]>
⋮----
// This is a simplified placeholder - in a real implementation you would:
// 1. Query the database for rewards matching the criteria
// 2. Filter by dates and episodes if provided
// 3. Sort and return the results
⋮----
// For demonstration purposes, we generate sample data
⋮----
/**
 * Generates sample reward records for testing and demonstration
 *
 * @param agentId - ID of the agent
 * @param episodeCount - Number of episodes to generate
 * @param actionsPerEpisode - Number of actions per episode
 * @returns Array of sample reward records
 */
function generateSampleRewardRecords(
  agentId: string,
  episodeCount: number,
  actionsPerEpisode: number
): RewardRecord[]
⋮----
const reward = Math.random() * 2 - 0.5; // Random between -0.5 and 1.5
⋮----
action: `action_${a % 3}`, // One of 3 possible actions
⋮----
// Sort by timestamp
⋮----
/**
 * Summarizes reward records for analysis
 *
 * @param records - Array of reward records
 * @returns Summary statistics for the rewards
 */
function summarizeRewards(records: RewardRecord[]):
⋮----
// Extract episodes
⋮----
// Calculate average reward
⋮----
// Calculate average episode return (sum of rewards in each episode)
⋮----
// Analyze state-actions
⋮----
// Create a simple hash of the state-action for grouping
⋮----
// Calculate average rewards per state-action
⋮----
// Sort by average reward
⋮----
// Get top and worst performers
````

## File: src/mastra/utils/memory-diagnostics.ts
````typescript
/**
 * Extremely simplified memory diagnostics utility
 */
⋮----
import { randomUUID } from "crypto";
import { Memory } from "@mastra/memory"; // Import the Memory class
import { LibSQLStore } from "@mastra/core/storage/libsql"; // Import storage implementation
import { LibSQLVector } from "@mastra/core/vector/libsql"; // Import vector store implementation
// import { PineconeVector } from "@mastra/pinecone"; // Import Pinecone vector store - Incompatible type
⋮----
// Configure basic stores for diagnostics (adjust config as needed)
// Ensure these dependencies are correctly configured for your environment
⋮----
/* LibSQLStore configuration */
url: process.env.LIBSQL_URL ?? "file:local.db", // Example: Use env var or default
⋮----
// Use LibSQLVector which should be compatible with MastraVector
/*
// User indicated they do not use LibSQLVector.
// The code below is commented out.
const diagnosticVector = new LibSQLVector({
  config: {
    /* LibSQLVector configuration - likely similar to LibSQLStore */
// url: process.env.LIBSQL_URL ?? "file:local_vector.db", // Use separate DB or same one
// authToken: process.env.LIBSQL_AUTH_TOKEN,
// Add other required LibSQLVector config like table names if needed
⋮----
// Add embedding function if required by LibSQLVector constructor
// embedding: yourEmbeddingFunction, // TODO: Provide an actual embedding function if required
⋮----
/**
 * Runs basic diagnostics on the Memory component.
 *
 * @returns A promise resolving to an object indicating success or failure,
 *          along with diagnostic information or an error message.
 * @throws {Error} If configuration is missing or invalid.
 */
export async function runMemoryDiagnostics()
⋮----
// Instantiate Memory with diagnostic stores
⋮----
// vector: diagnosticVector,
// Add any other required Memory configuration here
⋮----
// Generate test IDs
⋮----
// Use the memory instance
⋮----
resourceId: testId, // Add the resourceId associated with the thread
````

## File: src/mastra/workflows/Networks/agentNetwork.ts
````typescript
/**
 * @file src/mastra/workflows/Networks/agentNetwork.ts
 * @description Defines and exports various AgentNetworks for DeanmachinesAI,
 *              including specialized collaborative networks and a Mixture of Experts (MoE) network.
 * @version 1.1.0 - Added KnowledgeWorkMoENetwork, preserving original structure
 */
⋮----
import { google } from "@ai-sdk/google";
import { AgentNetwork, type AgentNetworkConfig } from "@mastra/core/network";
import { createResponseHook } from "../../hooks"; // Assuming this path is correct
import {
  researchAgent,
  analystAgent,
  writerAgent,
  rlTrainerAgent,
  dataManagerAgent,
} from "../../agents";
// Import the default export (agents object) for MoE configuration
import allAgents from "../../agents";
import { env } from "process";
import { DEFAULT_MODELS } from "../../agents/config"; // Import for MoE config
import { KnowledgeWorkMoENetwork } from "./knowledgeWorkMoE.network"; // Import the MoE network class
import { sharedMemory } from "../../database"; // Import shared memory for network config
⋮----
// Base configuration for all networks to match agent configuration
// NOTE: Hooks are removed here as they are not part of AgentNetworkConfig.
// Consult @mastra/core documentation for the correct way to configure hooks.
// Memory might be configured elsewhere (e.g., during execution).
⋮----
// memory: sharedMemory, // Removed: 'memory' is not part of AgentNetworkConfig
// hooks: { ... } // Removed hooks configuration from base
⋮----
// --- Original Hook Definitions (Unchanged) ---
⋮----
// Using 'any' temporarily, replace with actual response type
// Apply base response validation logic if needed (extracted from createResponseHook)
⋮----
// Add network-specific metadata
⋮----
...(validatedResponse as any).metadata, // Assuming metadata exists
⋮----
// Assuming similar structure if needed
⋮----
console.error("Content Creation Network error:", error); /* ... */
⋮----
/* ... validation and metadata ... */ return response;
⋮----
// --- End Original Hook Definitions ---
⋮----
// --- Original Network Instantiations (Unchanged except adding ID and ensuring memory) ---
⋮----
/**
 * DeanInsights Network
 *
 * A collaborative network focused on researching topics, analyzing data, and producing
 * well-structured reports with reinforcement learning-based improvements over time.
 */
⋮----
// id: "dean-insights", // ID is not part of AgentNetworkConfig, set via other means if necessary
...baseNetworkConfig, // Includes model and memory
model: baseNetworkConfig.model!, // Ensure model is explicitly provided and non-null
⋮----
// hooks: { ... } // Removed hooks from constructor - apply post-instantiation if needed
⋮----
/**
 * DataFlow Network
 *
 * A specialized network focused on data processing, file operations, and analysis
 */
⋮----
// id: "data-flow", // ID is not part of AgentNetworkConfig, set via other means if necessary
...baseNetworkConfig, // Includes model and memory
model: baseNetworkConfig.model!, // Ensure model is explicitly provided and non-null
⋮----
// hooks: { ... } // Removed hooks from constructor - apply post-instantiation if needed
⋮----
/**
 * ContentCreation Network
 *
 */
⋮----
// id: "content-creation", // ID is not part of AgentNetworkConfig, set via other means if necessary
...baseNetworkConfig, // Includes model and memory
model: baseNetworkConfig.model!, // Ensure model is explicitly provided and non-null
⋮----
// hooks: { ... } // Removed hooks from constructor - apply post-instantiation if needed
⋮----
// --- MoE Network Instantiation (Added) ---
⋮----
// 1. Define the expert agent IDs for the MoE network instance
// Explicitly type the array elements as keys of the allAgents object.
⋮----
// 'agenticAssistant' // Fallback agent is added automatically by the MoE class if valid & not listed.
⋮----
// 2. Configure the router model for the MoE network
const moeRouterConfig = DEFAULT_MODELS.GOOGLE_STANDARD; // Use a capable model for routing
⋮----
// 3. Instantiate the MoE network with a unique ID
⋮----
allAgents, // Pass the full agent registry
⋮----
"knowledge-work-moe-v1" // Unique ID for this network instance
// fallbackAgentId: 'agenticAssistant' // Default is usually fine
⋮----
// --- Apply Hooks to Networks ---
// NOTE: Direct assignment of hooks (e.g., network.onError) is not supported by the AgentNetwork type.
// Consult the @mastra/core documentation for the correct method to apply hooks
// (e.g., potentially via constructor configuration or execution options).
// The following lines are commented out to resolve the type errors:
⋮----
// deanInsightsNetwork.onError = deanInsightsHooks.onError;
// deanInsightsNetwork.onGenerateResponse = deanInsightsHooks.onGenerateResponse;
⋮----
// dataFlowNetwork.onError = dataFlowHooks.onError;
// dataFlowNetwork.onGenerateResponse = dataFlowHooks.onGenerateResponse; // Duplicate line removed
⋮----
// contentCreationNetwork.onError = contentCreationHooks.onError;
// contentCreationNetwork.onGenerateResponse = contentCreationHooks.onGenerateResponse;
⋮----
// knowledgeWorkMoENetwork.onError = async (error: Error) => {
//   console.error("MoE Network error:", error);
//   return {
//     text: "The MoE agent network encountered an error. Please try again with a more specific request.",
//     error: error.message,
//   };
// };
⋮----
// --- Original Helper Function (Revised to use final export map) ---
⋮----
/**
 * Helper function to get a specific agent network by its registered ID.
 *
 * @param networkId - The unique ID of the network to retrieve (e.g., "knowledge-work-moe-v1").
 * @returns The requested AgentNetwork instance or undefined if not found.
 */
export function getAgentNetwork(networkId: string): AgentNetwork | undefined
⋮----
// Directly access the exported 'networks' map using the provided ID
// This map is defined below and uses the correct string IDs as keys.
⋮----
// --- Final Export Map for Mastra Configuration (Updated) ---
⋮----
/**
 * Export all instantiated networks in a map format compatible with the Mastra instance configuration.
 * The keys MUST be the unique string IDs assigned during instantiation, used for invoking networks.
 */
⋮----
// Use the unique IDs assigned during instantiation as keys
⋮----
"knowledge-work-moe-v1": knowledgeWorkMoENetwork, // Add the MoE network using its ID
````

## File: src/mastra/workflows/Networks/productLaunchNetwork.ts
````typescript
/**
 * ProductLaunchNetwork Implementation
 *
 * This module implements a collaborative network that coordinates between
 * coding and marketing teams to support product launch activities.
 * It connects the Coder agent with the Copywriter agent to streamline
 * the creation of both code and marketing materials.
 */
⋮----
import { google } from "@ai-sdk/google";
import { AgentNetwork, type AgentNetworkConfig } from "@mastra/core/network";
import { createLogger } from "@mastra/core/logger";
import { coderAgent, copywriterAgent } from "../../agents";
import { createResponseHook } from "../../hooks";
⋮----
// Configure logger for the network
⋮----
/**
 * Hooks for the ProductLaunchNetwork
 */
⋮----
/**
 * ProductLaunchNetwork
 *
 * This network connects the Coder agent with the Copywriter agent to streamline
 * the creation of both code and marketing materials for product launches.
 *
 * @remarks
 * The network uses an LLM-based router to determine which agent to call based on
 * the task requirements. This enables dynamic collaboration between development
 * and marketing teams.
 */
⋮----
/**
 * Initialize the ProductLaunchNetwork
 *
 * @returns The initialized network instance
 */
export function initializeProductLaunchNetwork(): AgentNetwork
⋮----
// Export the initialized network
````

## File: src/mastra/agents/architect.agent.ts
````typescript
/**
 * Architecture Agent Implementation
 *
 * This module implements the Architecture Agent based on its configuration.
 */
⋮----
import { sharedMemory } from "../database";
import { createAgentFromConfig } from "./base.agent";
import {architectConfig} from "./config";
import { createLogger } from "@mastra/core/logger";
⋮----
/**
 * Architecture Agent
 *
 * Specializes in system design, architecture decisions, and technical planning.
 *
 * @remarks
 * This agent is responsible for creating architecture diagrams, making technical
 * decisions, and providing guidance on system design and implementation.
 */
⋮----
memory: sharedMemory, // Following RULE-MemoryInjection
⋮----
export type ArchitectAgent = typeof architectAgent;
````

## File: src/mastra/agents/codeDocumenter.agent.ts
````typescript
/**
 * Code Documenter Agent Implementation
 *
 * This module implements the Code Documenter Agent based on its configuration.
 */
⋮----
import { sharedMemory } from "../database";
import { createAgentFromConfig } from "./base.agent";
import { codeDocumenterConfig } from "./config/"; // Import directly
import { createLogger } from "@mastra/core/logger";
⋮----
/**
 * Code Documenter Agent
 *
 * Specializes in creating comprehensive code documentation.
 *
 * @remarks
 * This agent is responsible for creating API documentation, writing code comments,
 * generating user guides, and ensuring documentation stays synchronized with code.
 * @version 1.0.0
 */
⋮----
memory: sharedMemory, // Following RULE-MemoryInjection
⋮----
export type CodeDocumenterAgent = typeof codeDocumenterAgent;
````

## File: src/mastra/agents/coder.agent.ts
````typescript
/**
 * Coder Agent Implementation
 *
 * This module implements the Coder Agent responsible for code generation,
 * analysis, and refactoring tasks within the DeanmachinesAI system.
 */
⋮----
import { Agent } from "@mastra/core/agent";
import { createAgentFromConfig } from "./base.agent";
import { coderAgentConfig } from "./config";
import { createLogger } from "@mastra/core/logger";
import { sharedMemory } from "../database";
⋮----
// Configure logger for the coder agent
⋮----
/**
 * Initialize the coder agent instance using its configuration
 *
 * @returns The initialized coder agent instance
 */
export function initializeCoderAgent(): Agent
⋮----
memory: sharedMemory, // Following RULE-MemoryInjection
⋮----
/**
 * Singleton instance of the coder agent
 */
⋮----
export type CoderAgent = typeof coderAgent;
````

## File: src/mastra/agents/debugger.agent.ts
````typescript
/**
 * Debugger Agent Implementation
 *
 * This module implements the Debugger Agent based on its configuration.
 */
⋮----
import { sharedMemory } from "../database";
import { createAgentFromConfig } from "./base.agent";
import {debuggerConfig} from "./config";
import { createLogger } from "@mastra/core/logger";
⋮----
/**
 * Debugger Agent
 *
 * Specializes in identifying and fixing code issues and bugs.
 *
 * @remarks
 * This agent is responsible for analyzing error logs, debugging code execution,
 * and proposing fixes for bugs and performance issues.
 */
⋮----
memory: sharedMemory, // Following RULE-MemoryInjection
⋮----
export type DebuggerAgent = typeof debuggerAgent;
````

## File: src/mastra/agents/marketResearch.agent.ts
````typescript
/**
 * Market Research Agent Implementation
 *
 * This module implements the Market Research Agent based on its configuration.
 */
⋮----
import { sharedMemory } from "../database";
import { createAgentFromConfig } from "./base.agent";
import {marketResearchAgentConfig} from "./config";
import { createLogger } from "@mastra/core/logger";
⋮----
/**
 * Market Research Agent
 *
 * Specializes in analyzing markets, competitors, and user needs.
 *
 * @remarks
 * This agent is responsible for gathering and analyzing market data,
 * conducting competitive analysis, and providing actionable insights.
 */
⋮----
memory: sharedMemory, // Following RULE-MemoryInjection
⋮----
export type MarketResearchAgent = typeof marketResearchAgent;
````

## File: src/mastra/agents/seoAgent.agent.ts
````typescript
/**
 * SEO Agent Implementation
 *
 * This module implements the SEO Agent based on its configuration.
 */
⋮----
import { sharedMemory } from "../database";
import { createAgentFromConfig } from "./base.agent";
import { seoAgentConfig } from "./config";
import { createLogger } from "@mastra/core/logger";
⋮----
/**
 * SEO Agent
 *
 * Specializes in search engine optimization strategies and implementation.
 *
 * @remarks
 * This agent is responsible for keyword research, content optimization,
 * and improving website visibility and rankings in search engines.
 */
⋮----
memory: sharedMemory, // Following RULE-MemoryInjection
⋮----
export type SEOAgent = typeof seoAgent;
````

## File: src/mastra/agents/socialMedia.agent.ts
````typescript
/**
 * Social Media Agent Implementation
 *
 * This module implements the Social Media Agent based on its configuration.
 */
⋮----
import { sharedMemory } from "../database";
import { createAgentFromConfig } from "./base.agent";
import { socialMediaAgentConfig } from "./config";
import { createLogger } from "@mastra/core/logger";
⋮----
/**
 * Social Media Agent
 *
 * Specializes in creating and managing social media content and campaigns.
 *
 * @remarks
 * This agent is responsible for creating platform-specific content,
 * planning social media campaigns, and analyzing engagement metrics.
 */
⋮----
memory: sharedMemory, // Following RULE-MemoryInjection
⋮----
export type SocialMediaAgent = typeof socialMediaAgent;
````

## File: src/mastra/services/langchain.ts
````typescript
/**
 * LangChain integration service for Mastra AI.
 *
 * Provides utility functions to integrate LangChain functionalities
 * with Mastra agents and workflows.
 */
⋮----
import { BaseCallbackHandler } from "@langchain/core/callbacks/base";
import { ChatOpenAI } from "@langchain/openai";
import { ChatGoogleGenerativeAI } from "@langchain/google-genai";
import { ChatAnthropic } from "@langchain/anthropic";
import { ConversationChain } from "langchain/chains";
import { SystemMessage } from "@langchain/core/messages";
import { PromptTemplate, ChatPromptTemplate } from "@langchain/core/prompts";
import { env } from "process";
import { configureLangSmithTracing } from "./langsmith";
⋮----
/**
 * Model provider options for LangChain
 */
export type ModelProvider = "openai" | "google" | "anthropic";
⋮----
/**
 * Configuration options for LangChain models
 */
export interface LangChainConfig {
  /** The model provider to use */
  provider?: ModelProvider;
  /** Specific model name to use */
  modelName?: string;
  /** Whether to enable tracing with LangSmith */
  enableTracing?: boolean;
  /** Temperature setting for model responses (0-1) */
  temperature?: number;
  /** Maximum number of tokens in response */
  maxTokens?: number;
  /** Custom callback handlers for LangChain */
  callbacks?: BaseCallbackHandler[];
}
⋮----
/** The model provider to use */
⋮----
/** Specific model name to use */
⋮----
/** Whether to enable tracing with LangSmith */
⋮----
/** Temperature setting for model responses (0-1) */
⋮----
/** Maximum number of tokens in response */
⋮----
/** Custom callback handlers for LangChain */
⋮----
/**
 * Creates a configured LangChain chat model based on provider
 *
 * @param config - Configuration options for the LangChain model
 * @returns A configured chat model ready for use with LangChain
 * @throws {Error} When required API keys are missing
 */
export function createLangChainModel(config: LangChainConfig =
⋮----
// Set up LangSmith tracing if enabled
⋮----
// Create model based on provider
⋮----
/**
 * Creates a conversation chain with system instructions
 *
 * @param systemPrompt - System instructions for the conversation
 * @param config - LangChain model configuration
 * @returns A configured conversation chain
 */
export function createConversationChain(
  systemPrompt: string,
  config?: LangChainConfig
)
⋮----
/**
 * Creates a chain using LangChain Expression Language (LCEL) with a custom prompt template
 *
 * @param promptTemplate - The prompt template string with {variables}
 * @param config - LangChain model configuration
 * @returns A configured LCEL chain
 */
export function createLLMChain(
  promptTemplate: string,
  config?: LangChainConfig
)
⋮----
// Using LCEL pipe pattern instead of deprecated LLMChain
````

## File: src/mastra/tools/graphRag.ts
````typescript
/**
 * Graph-based Retrieval Augmented Generation (GraphRAG) tools for Mastra AI.
 *
 * This module provides advanced document retrieval that leverages graph relationships
 * between documents to improve context and relevance of retrieved information.
 */
⋮----
import { createTool } from "@mastra/core/tools";
import { z } from "zod";
import { Pinecone } from "@pinecone-database/pinecone";
import { PineconeStore } from "@langchain/pinecone";
import { GoogleGenerativeAIEmbeddings } from "@langchain/google-genai";
import { Document } from "langchain/document";
import { createEmbeddings } from "../database/vector-store";
import { createLangSmithRun, trackFeedback } from "../services/langsmith";
import { createLangChainModel } from "../services/langchain";
import { env } from "process";
// Import Langfuse service for observability.
import { langfuse } from "../services/langfuse";
⋮----
/**
 * Graph node representing a document or chunk with its connections.
 */
export interface GraphNode {
  /** Unique identifier for the node */
  id: string;
  /** Document content */
  content: string;
  /** Metadata about the document */
  metadata: Record<string, unknown>;
  /** IDs of connected nodes */
  connections: string[];
  /** Connection weights/strengths (0-1) */
  connectionWeights: Record<string, number>;
}
⋮----
/** Unique identifier for the node */
⋮----
/** Document content */
⋮----
/** Metadata about the document */
⋮----
/** IDs of connected nodes */
⋮----
/** Connection weights/strengths (0-1) */
⋮----
/**
 * GraphDocument augments a LangChain Document with GraphNode metadata.
 */
export type GraphDocument = Document & { metadata: GraphNode };
⋮----
/**
 * Creates graph relationships between documents based on semantic similarity.
 *
 * @param documents - List of documents to create relationships between.
 * @param embeddings - Embeddings model for calculating similarity.
 * @param threshold - Similarity threshold for creating connections (default 0.7).
 * @returns Documents enriched with graph relationship metadata.
 * @throws {Error} If vector dimensions mismatch.
 */
async function createGraphRelationships(
  documents: Document[],
  embeddings: GoogleGenerativeAIEmbeddings,
  threshold: number = 0.7
): Promise<GraphDocument[]>
⋮----
// Map input documents to GraphDocuments ensuring metadata conforms to GraphNode.
⋮----
// Create embeddings for all documents.
⋮----
// Calculate similarity between all pairs of documents.
⋮----
// Create a connection if similarity exceeds threshold.
⋮----
/**
 * Calculates cosine similarity between two vectors.
 *
 * @param vec1 - First vector.
 * @param vec2 - Second vector.
 * @returns Similarity score between 0 and 1.
 * @throws {Error} If vector lengths differ.
 */
function calculateCosineSimilarity(vec1: number[], vec2: number[]): number
⋮----
/**
 * Tool for creating a graph-based document store with relationships.
 */
⋮----
// Create embeddings model.
⋮----
// Convert input to GraphDocuments.
⋮----
// Create graph relationships.
⋮----
// Count total connections (edges).
⋮----
// Store graph in vector database.
⋮----
// Track success in LangSmith.
⋮----
/**
 * Tool for graph-based document retrieval with relationship exploration.
 *
 * Now uses createLangChainModel to ensure the LangChain model is instantiated and functional,
 * and logs a generation event via Langfuse.
 */
⋮----
// Instantiate LangChain model to ensure createLangChainModel is read and functional.
⋮----
// Log model instantiation via Langfuse.
⋮----
// Initialize Pinecone client.
⋮----
// Connect to vector store.
⋮----
// Initial document retrieval.
⋮----
// Process and normalize results.
⋮----
// Explore graph up to maxHopCount.
⋮----
// Format and sort results.
⋮----
// Log generation event using Langfuse.
````

## File: src/mastra/tools/memoryQueryTool.ts
````typescript
import { createTool } from "@mastra/core/tools";
import { createLogger } from "@mastra/core/logger";
import { z } from "zod";
// Assuming sharedMemory is an instance of the Memory class from @mastra/memory
import { sharedMemory } from "../database";
// Import specific types if available and known, otherwise use general types
import type { CoreMessage, ToolExecutionContext } from "@mastra/core"; // Assuming CoreMessage type exists
⋮----
/**
 * Schema for selecting messages by specific IDs with context.
 */
⋮----
/**
 * Schema for selecting messages based on various criteria.
 * Aligns with the `selectBy` parameter of `memory.query()`.
 */
⋮----
/**
 * Input schema for the Memory Query Tool, aligned with `memory.query()`.
 */
⋮----
// resourceId: z.string().optional().describe("Optional ID of the resource owning the thread for validation."),
// threadConfig: z.any().optional().describe("Optional memory configuration overrides for this query."), // Type depends on MemoryConfig definition
⋮----
/**
 * Output schema for the Memory Query Tool.
 * Returns an array of matching messages found in memory.
 */
⋮----
// Using z.unknown() for messages as CoreMessage structure might be complex or not fully defined here
⋮----
// uiMessages: z.array(z.unknown()).optional().describe("Optional array of messages formatted for UI display."), // Include if needed
⋮----
/**
 * Creates a tool for querying messages stored in the Mastra Memory system for a specific thread.
 *
 * @remarks
 * This tool allows agents to retrieve messages based on criteria like recency,
 * semantic similarity, or specific IDs. It interacts directly with the
 * configured memory provider (LibSQL) via the `memory.query()` method.
 * Retrieving specific structured data (like feedback or rewards) depends on that
 * data being present within the message content/metadata or discoverable via semantic search.
 * This tool does *not* query arbitrary structured data types directly.
 *
 * @param {ToolExecuteParams<typeof memoryQueryInputSchema>} params - The parameters object, conforming to the input schema.
 * @param {string} params.threadId - The ID of the thread to query.
 * @param {object} params.selectBy - The criteria for selecting messages.
 * @returns {Promise<{messages: Array<any>}>} A promise resolving to the query results.
 * @throws {Error} If the memory system is unavailable or the query fails.
 */
⋮----
id: "memory-query", // Unique ID for the tool
⋮----
// Access the validated input from context
⋮----
// Use the documented memory.query() method
const { messages /*, uiMessages */ } = await sharedMemory.query({
⋮----
// resourceId, // Pass if needed/available
// threadConfig, // Pass if needed/available
⋮----
// Ensure messages is always an array
⋮----
// Return structure matching the output schema
⋮----
// --- Integration into tools/index.ts (Reminder) ---
// 1. Import `memoryQueryTool` in `src/mastra/tools/index.ts`.
// 2. Add it to `allToolsArray` and `allToolsMap`.
// 3. Consider adding it to `utilityTools` or a new `memoryTools` group.
// 4. Add its ID ('memory-query') to the `toolIds` array in the configuration
//    of any agent that needs to use it (e.g., rlTrainerAgent, analystAgent).
````

## File: src/mastra/tools/readwrite.ts
````typescript
/**
 * File Reading and Writing Tools for Mastra AI.
 *
 * This module provides tools for reading from and writing to files in the filesystem
 * with support for different file formats, encodings, and write modes.
 */
⋮----
import { createTool } from "@mastra/core/tools";
import { z } from "zod";
import { promises as fs } from "fs";
import { resolve, dirname, extname, join } from "path";
import { createLangSmithRun, trackFeedback } from "../services/langsmith";
⋮----
/**
 * Supported file encoding types
 */
export enum FileEncoding {
  /** UTF-8 text encoding */
  UTF8 = "utf8",
  /** ASCII text encoding */
  ASCII = "ascii",
  /** UTF-16 Little Endian encoding */
  UTF16LE = "utf16le",
  /** Latin1 encoding */
  LATIN1 = "latin1",
  /** Base64 encoding */
  BASE64 = "base64",
  /** Hex encoding */
  HEX = "hex",
}
⋮----
/** UTF-8 text encoding */
⋮----
/** ASCII text encoding */
⋮----
/** UTF-16 Little Endian encoding */
⋮----
/** Latin1 encoding */
⋮----
/** Base64 encoding */
⋮----
/** Hex encoding */
⋮----
/**
 * File write modes
 */
export enum FileWriteMode {
  /** Overwrite the file if it exists */
  OVERWRITE = "overwrite",
  /** Append to the file if it exists */
  APPEND = "append",
  /** Create a new file, fail if the file exists */
  CREATE_NEW = "create-new",
}
⋮----
/** Overwrite the file if it exists */
⋮----
/** Append to the file if it exists */
⋮----
/** Create a new file, fail if the file exists */
⋮----
/**
 * Base path for knowledge folder
 */
⋮----
/**
 * Validates if a path is within the knowledge folder
 */
function isKnowledgePath(path: string): boolean
⋮----
/**
 * Resolves a knowledge folder path
 */
function resolveKnowledgePath(path: string): string
⋮----
/**
 * Tool for reading files from the filesystem
 */
⋮----
// Resolve the absolute path
⋮----
// Check if the file exists
⋮----
// Get file stats
⋮----
// Check file size
⋮----
// Read the file
⋮----
// Handle line-based reading if requested
⋮----
// Extract the requested lines
⋮----
// Track success in LangSmith
⋮----
// Track failure in LangSmith
⋮----
/**
 * TOOL NAME UPDATE: Changed export id from "write-to-file" to "write-file"
 * to match the research-agent's requirement.
 */
⋮----
/**
 * Tool for writing content to files in the filesystem
 */
⋮----
// Resolve the absolute path
⋮----
// Check content size
⋮----
// Create parent directories if requested
⋮----
// Check if the file exists
⋮----
// File doesn't exist
⋮----
// Handle write mode
⋮----
// Write or append to the file based on the mode
⋮----
// Track success in LangSmith
⋮----
// Track failure in LangSmith
⋮----
// Ensure the execute method exists before calling it
⋮----
// Modify context to use knowledge path and provide default startLine
⋮----
// Track failure in LangSmith
⋮----
// Ensure the execute method exists before calling it
⋮----
// Modify context to use knowledge path and include default maxSizeBytes
⋮----
// Provide the default value from writeToFileTool's schema
⋮----
// Track failure in LangSmith
⋮----
// Original tools are already exported when defined
````

## File: .env.example
````
BRAVE_API_KEY="<brave-api-key>"
EXA_API_KEY="<exa-search-api-key>"
# Sample Brave API key, replace with your own
GOOGLE_CSE_KEY="<key_here>"
# Sample Google Custom Search Engine ID, replace with your own
GOOGLE_CSE_ID="<id_here>"
# Sample Tavily API key, replace with your own
# This is a sample Tavily API key, replace with your own
TAVILY_API_KEY="<tavily_api_key_here>"
# Sample Google API key, replace with your own
GOOGLE_AI_API_KEY="google_api_key_here"
MAX_TOKENS="8192"
MAX_TOKENS_EMBEDDING="8192"
MAX_CONTEXT_TOKENS="1000000"

GOOGLE_GENERATIVE_AI_API_KEY="google_api_key_here"
MODEL="models/gemini-2.0-flash"
EMBEDDING_MODEL="models/gemini-embedding-exp-03-07"

# Sample Google Custom Search Engine ID, rconstructor using the cseId
GOOGLE_CSE_ID="cse-id_here"
# Key constructor using the apiKey
GOOGLE_API_KEY="google_api_key_here"

# Sample Langchain API key, replace with your own
LANGCHAIN_API_KEY="langchain_api_key"

# Sample Turso database URL and key, replace with your own
TURSO_DATABASE_URL="libsql://<id>.aws-us-east-1.turso.io"
TURSO_DATABASE_KEY="the_turso_database_key_here"

# Sample Langsmith API key and service key, replace with your own
LANGSMITH_TRACING_V2="true"
LANGSMITH_ENDPOINT="https://api.smith.langchain.com"
LANGSMITH_API_KEY="langsmith_api_key"
LANGSMITH_SERVICE_KEY="langsmith_service_key"

# Sample Pinecone API key, replace with your own
PINECONE_API_KEY="pinecone_api_key"
PINECONE_ENV="us-east-1"
PINECONE_HOST="https://<id here>.pinecone.io"
PINECONE_MODEL="llama-text-embed-v2"
PINECONE_INDEX="Default"
PINECONE_DIMENSION="2048"
PINECONE_METRIC="cosine"
PINECONE_NAMESPACE="Default"

# Sample Upstash Vector REST URL, replace with your own
UPSTASH_VECTOR_REST_URL="https://<id here>.us1-vector.upstash.io"
UPSTASH_VECTOR_REST_TOKEN="vector-rest-token"
UPSTASH_INDEX="name_of_your_index"
UPSTASH_REDIS_URL="url"
UPSTASH_REDIS_TOKEN="upstash_redis_token"

# Sample ElevenLabs API key, replace with your own
ELEVENLABS_API="elevenslabs_voice_api_key"

EXA_API_KEY="exa-search-api-key"

# Langfuse API keys
LANGFUSE_PUBLIC_KEY="your_actual_langfuse_public_key"
LANGFUSE_SECRET_KEY="your_actual_langfuse_secret_key"
LANGFUSE_HOST="https://us.cloud.langfuse.com"

# Sample E2B API key, replace with your own
E2B_API_KEY="your_e2b_api_key"
# Sample GitHub API key, replace with your own
GITHUB_API_KEY="your_github_api_key"
# Sample Google Application Credentials, replace with your own
# This is the path to your Google Cloud service account key file
# Make sure to replace <user> with your actual username
GOOGLE_CLOUD_PROJECT="<user>"
VERTEX_LOCATION="us-central1"
````

## File: src/mastra/agents/dataManager.agent.ts
````typescript
/**
 * Data Manager Agent Implementation
 *
 * This agent is specialized in managing data operations, file organization,
 * storage, and retrieval of information across the system.
 */
⋮----
import { createAgentFromConfig } from "./base.agent";
import { dataManagerAgentConfig } from "./config";
import { sharedMemory } from "../database";
import { createLogger } from "@mastra/core/logger";
⋮----
/**
 * Data Manager Agent with file and storage management capabilities
 *
 * @remarks
 * This agent specializes in organizing, storing, retrieving, and managing
 * data assets across the system, including file operations and vector database management.
 */
⋮----
memory: sharedMemory, // Following RULE-MemoryInjection
````

## File: src/mastra/agents/research.agent.ts
````typescript
/**
 * Research Agent Implementation
 *
 * This agent is specialized in finding, gathering, and synthesizing information
 * from various sources including web searches, document repositories, and files.
 */
⋮----
import { createAgentFromConfig } from "./base.agent";
import { researchAgentConfig } from "./config";
import { sharedMemory } from "../database";
import { createLogger } from "@mastra/core/logger";
⋮----
/**
 * Research Agent with web search capabilities
 *
 * @remarks
 * This agent can perform web searches, read and write files, and maintain
 * research context across interactions using semantic memory.
 */
⋮----
memory: sharedMemory, // Following RULE-MemoryInjection
⋮----
export type ResearchAgent = typeof researchAgent;
````

## File: src/mastra/agents/rlTrainer.agent.ts
````typescript
/**
 * RL Trainer Agent Implementation
 *
 * This agent is specialized in reinforcement learning, collecting and analyzing
 * feedback, and optimizing agent behaviors based on performance data.
 */
⋮----
import { createAgentFromConfig } from "./base.agent";
import { rlTrainerAgentConfig } from "./config";
import { sharedMemory } from "../database";
import { createLogger } from "@mastra/core/logger";
⋮----
/**
 * RL Trainer Agent with reinforcement learning capabilities
 *
 * @remarks
 * This agent specializes in collecting user feedback, analyzing agent performance,
 * and implementing reinforcement learning techniques to improve agent behaviors.
 */
⋮----
memory: sharedMemory, // Following RULE-MemoryInjection
⋮----
/**
 * RL Trainer Agent with reinforcement learning capabilities
 *
 * @remarks
 * This agent specializes in collecting user feedback, analyzing agent performance,
 * and implementing reinforcement learning techniques to improve agent behaviors.
 */
export type RLTrainerAgent = typeof rlTrainerAgent;
````

## File: src/mastra/agents/uiUxCoder.agent.ts
````typescript
/**
 * UI/UX Coder Agent Implementation
 *
 * This module implements the UI/UX Coder Agent based on its configuration.
 */
⋮----
import { sharedMemory } from "../database";
import { createAgentFromConfig } from "./base.agent";
import { uiUxCoderConfig } from "./config";
import { createLogger } from "@mastra/core/logger";
⋮----
/**
 * UI/UX Coder Agent
 *
 * Specializes in frontend development and user experience implementation.
 *
 * @remarks
 * This agent is responsible for implementing user interfaces based on designs,
 * creating responsive layouts, and implementing intuitive user interactions.
 */
⋮----
memory: sharedMemory, // Following RULE-MemoryInjection
````

## File: src/mastra/database/index.ts
````typescript
/**
 * Database configuration for memory persistence using LibSQL.
 *
 * This module sets up the LibSQL adapter for Mastra memory persistence,
 * allowing agent conversations and context to be stored reliably.
 */
⋮----
import { LibSQLStore } from "@mastra/core/storage/libsql";
import { LibSQLVector } from "@mastra/core/vector/libsql";
import { Memory } from "@mastra/memory";
import type { MastraStorage, MastraVector } from "@mastra/core";
⋮----
// Define the memory configuration type
export interface MemoryConfig {
  lastMessages: number;
  semanticRecall: {
    topK: number;
    messageRange: {
      before: number;
      after: number;
    };
  };
  workingMemory: {
    enabled: boolean;
    type: "text-stream";
  };
  threads: {
    generateTitle: boolean;
  };
}
⋮----
// Default memory configuration that works well for most agents
⋮----
/**
 * Creates a new Memory instance with LibSQL storage and vector capabilities.
 * @param options Memory configuration options
 * @returns Configured Memory instance
 */
export function createMemory(
  options: Partial<MemoryConfig> = defaultMemoryConfig
): Memory
⋮----
// Initialize LibSQL storage
⋮----
// Initialize LibSQL vector store for semantic search
⋮----
// Export shared memory instance
⋮----
// Re-export Memory type for convenience
````

## File: src/mastra/tools/vectorquerytool.ts
````typescript
/**
 * Vector Query Tool for semantic search over vector databases.
 *
 * This module creates and exports tools for semantic search over vector stores,
 * with support for reranking to improve search result relevance.
 */
⋮----
import { google } from "@ai-sdk/google";
import { z } from "zod";
import { encodingForModel } from "js-tiktoken";
import { createVectorQueryTool } from "@mastra/rag";
import { env } from "process";
import { createLogger } from "@mastra/core/logger";
import {
  MastraEmbeddingAdapter,
  createEmbeddings,
} from "../database/vector-store";
import { AsyncCaller } from "@langchain/core/utils/async_caller";
⋮----
// Configure logger
⋮----
// Environment validation
⋮----
// Validate environment
⋮----
/**
 * Configuration for Vector Query Tool
 */
export interface VectorQueryConfig {
  vectorStoreName?: string;
  indexName?: string;
  enableFilters?: boolean;
  id?: string;
  description?: string;
  embeddingProvider?: "google" | "tiktoken";
  topK?: number;
  tokenEncoding?: string;
  dimensions?: number;
  apiKey?: string;
}
⋮----
/**
 * Creates a Vector Query Tool with specified configuration
 */
export function createMastraVectorQueryTool(config: VectorQueryConfig =
⋮----
// Get configuration values with defaults
⋮----
// Create embedding model
⋮----
// Create a tiktoken adapter - using type assertion to avoid issues with private properties
⋮----
// client property is removed as it's private
⋮----
// Get tokenizer
⋮----
// Convert text to tokens
⋮----
// Create embedding from tokens
⋮----
// Pad embedding if needed
⋮----
// Use the adapter with createEmbeddings with type assertion
⋮----
// Use Google embeddings
⋮----
// Create reranker
⋮----
// Tool ID and description
⋮----
// Create and return the tool
⋮----
// Default vector query tool instance with tiktoken
⋮----
// Google embeddings variant
⋮----
// Tool with filters enabled
````

## File: .gitignore
````
output.txt
node_modules
dist
.mastra


*.db
.repomix/bundles.json
.repomix
gcp-vertexai-credentials.json
.env
.roo
.env.development
````

## File: src/mastra/agents/base.agent.ts
````typescript
/**
 * Base Agent Implementation
 *
 * This module provides utility functions to create agents from configurations,
 * ensuring consistent agent creation patterns across the application.
 */
⋮----
import { Agent } from "@mastra/core/agent";
import { Tool } from "@mastra/core/tools";
import { createLogger } from "@mastra/core/logger";
import { sharedMemory } from "../database";
import {
  BaseAgentConfig,
  defaultErrorHandler,
  DEFAULT_MODEL_ID,
  DEFAULT_MAX_TOKENS,
  DEFAULT_MAX_CONTEXT_TOKENS,
  defaultResponseValidation,
  type ResponseHookOptions,
  createModelInstance
} from "./config/index";
import { createResponseHook } from "../hooks";
import { allToolsMap } from "../tools";
⋮----
// Configure logger for agent initialization
⋮----
/**
 * Creates an agent instance from a configuration object and options
 *
 * @param params - Object containing configuration and agent options
 * @param params.config - The agent configuration object
 * @param params.memory - The memory instance to be injected into the agent (following RULE-MemoryInjection)
 * @param params.onError - Optional error handler callback function
 * @returns A configured Agent instance
 * @throws Error if required tools are not available
 */
export function createAgentFromConfig({
  config,
  memory,
  onError,
}: {
  config: BaseAgentConfig;
  memory: typeof sharedMemory;
onError?: (error: Error) => Promise<
⋮----
// Validate configuration
⋮----
// Resolve tools from toolIds
⋮----
// Log and throw error for missing tools
⋮----
// Create response hook if validation options are provided
⋮----
// Create and return the agent instance
⋮----
// Create model instance using the new modelConfig property
⋮----
memory, // Using injected memory instead of global reference
⋮----
...(onError ? { onError } : {}), // Add error handler if provided
````

## File: src/mastra/agents/config/agentic.config.ts
````typescript
/**
 * Agentic-style Agent Configuration
 *
 * This file configures a Mastra agent with advanced capabilities,
 * leveraging Mastra's core features and compatible tools.
 */
⋮----
import { z, type ZodTypeAny } from "zod";
import type { Tool } from "@mastra/core/tools";
import {
  BaseAgentConfig,
  DEFAULT_MODELS,
  defaultResponseValidation
} from "./config.types";
⋮----
/**
 * Configuration for retrieving relevant tools for the agent
 *
 * @param toolIds - Array of tool identifiers to include
 * @param allTools - Map of all available tools
 * @returns Record of tools mapped by their IDs
 * @throws {Error} When required tools are missing
 */
export function getToolsFromIds(
  toolIds: string[],
  allTools: ReadonlyMap<
    string,
    Tool<z.ZodTypeAny | undefined, z.ZodTypeAny | undefined>
  >
): Record<string, Tool<z.ZodTypeAny | undefined, z.ZodTypeAny | undefined>>
⋮----
/**
 * Configuration for the agentic assistant
 */
⋮----
/**
 * Schema for structured agent responses
 */
⋮----
/**
 * Type for structured responses from the agent
 */
export type AgenticResponse = z.infer<typeof agenticResponseSchema>;
⋮----
export type AgenticAssistantConfig = typeof agenticAssistantConfig;
````

## File: src/mastra/agents/config/architect.config.ts
````typescript
/**
 * Architecture Agent Configuration
 *
 * This module defines the configuration for the Architecture Agent,
 * which specializes in system design, architecture decisions, and technical planning.
 */
⋮----
import { z, type ZodTypeAny } from "zod";
import type { Tool } from "@mastra/core/tools";
import {
  BaseAgentConfig,
  DEFAULT_MODELS,
  defaultResponseValidation,
} from "./config.types";
⋮----
/**
 * Configuration for retrieving relevant tools for the agent
 *
 * @param toolIds - Array of tool identifiers to include
 * @param allTools - Map of all available tools
 * @returns Record of tools mapped by their IDs
 * @throws {Error} When required tools are missing
 */
export function getToolsFromIds(
  toolIds: string[],
  allTools: ReadonlyMap<
    string,
    Tool<ZodTypeAny | undefined, ZodTypeAny | undefined>
  >
): Record<string, Tool<ZodTypeAny | undefined, ZodTypeAny | undefined>>
⋮----
/**
 * Architecture Agent Configuration
 *
 * @remarks
 * The Architecture Agent focuses on system design, technical decision making,
 * and creating architectural plans. It analyzes requirements and provides
 * guidance on component structures, interactions, and technical trade-offs.
 */
⋮----
export type ArchitectConfig = typeof architectConfig;
````

## File: src/mastra/agents/config/codeDocumenter.config.ts
````typescript
/**
 * Code Documenter Agent Configuration
 *
 * This module defines the configuration for the Code Documenter Agent,
 * which specializes in creating comprehensive code documentation.
 */
⋮----
import { z, type ZodTypeAny } from "zod";
import type { Tool } from "@mastra/core/tools";
import {
  BaseAgentConfig,
  DEFAULT_MODELS,
  defaultResponseValidation,
} from "./config.types";
⋮----
// Note: This function might be redundant if tool resolution happens centrally in base.agent.ts
export function getToolsFromIds(
  toolIds: string[],
  allTools: ReadonlyMap<
    string,
    Tool<ZodTypeAny | undefined, ZodTypeAny | undefined>
  >
): Record<string, Tool<ZodTypeAny | undefined, ZodTypeAny | undefined>>
⋮----
/**
 * Detailed instructions for the Code Documenter Agent.
 */
⋮----
/**
 * Configuration object for the Code Documenter Agent.
 * THIS IS THE VALUE BEING EXPORTED.
 */
// --- ENSURE 'export' IS PRESENT HERE ---
⋮----
//"github",
⋮----
/**
 * Schema for structured code documenter responses
 * THIS IS A VALUE, BUT NOT EXPORTED (to fix TS6133).
 */
// --- ENSURE 'export' IS REMOVED HERE ---
⋮----
/**
 * Type for structured responses from the Code Documenter agent
 * THIS IS A TYPE BEING EXPORTED.
 */
// --- Use PascalCase ---
export type CodeDocumenterResponse = z.infer<
  typeof codeDocumenterResponseSchema
>;
⋮----
/**
 * Type derived from the config object
 * THIS IS A TYPE BEING EXPORTED.
 */
// --- Use PascalCase ---
export type CodeDocumenterConfig = typeof codeDocumenterConfig;
````

## File: src/mastra/agents/config/coder.config.ts
````typescript
/**
 * Coder Agent Configuration
 *
 * This module defines the configuration for the Coder Agent, which specializes in
 * generating, analyzing, and refactoring code in various programming languages.
 */
⋮----
import { z, type ZodTypeAny } from "zod";
import type { Tool } from "@mastra/core/tools";
import {
  BaseAgentConfig,
  DEFAULT_MODELS,
  defaultResponseValidation,
} from "./config.types";
⋮----
/**
 * Configuration for retrieving relevant tools for the agent
 *
 * @param toolIds - Array of tool identifiers to include
 * @param allTools - Map of all available tools
 * @returns Record of tools mapped by their IDs
 * @throws {Error} When required tools are missing
 */
export function getToolsFromIds(
  toolIds: string[],
  allTools: ReadonlyMap<
    string,
    Tool<ZodTypeAny | undefined, ZodTypeAny | undefined>
  >
): Record<string, Tool<ZodTypeAny | undefined, ZodTypeAny | undefined>>
⋮----
/**
 * Configuration for the Coder Agent.
 *
 * @remarks
 * The Coder Agent focuses on code generation, refactoring, and analysis
 * using code manipulation tools, file operations, and GitHub integration.
 *
 * @property {string[]} toolIds - The list of tool IDs required by the agent.
 */
⋮----
"read-file",         // Correct ID for reading files
"write-file",        // Correct ID for writing files
"search-documents",  // For searching relevant code snippets/docs
// "github",         // Omitted - Needs clarification on how GitHub tools are registered in tools/index.ts
"memory-query",      // Correct ID for querying conversation memory
"analyze-content",   // For understanding code/text content
"calculator",        // Correct ID for calculations (e.g., complexity analysis)              // For executing code snippets safely
// Add other relevant tools like specific search tools if needed
⋮----
/**
 * Schema for structured coder agent responses
 */
⋮----
/**
 * Type for structured responses from the Coder agent
 */
export type CoderResponse = z.infer<typeof coderResponseSchema>;
⋮----
/**
 * Type for the Coder Agent configuration
 */
export type CoderAgentConfig = typeof coderAgentConfig;
````

## File: src/mastra/agents/config/copywriter.config.ts
````typescript
/**
 * Copywriter Agent Configuration
 *
 * This module defines the configuration for the Copywriter Agent, which specializes in
 * creating compelling marketing copy and content for various channels.
 */
⋮----
import { z, type ZodTypeAny } from "zod";
import type { Tool } from "@mastra/core/tools";
import {
  BaseAgentConfig,
  DEFAULT_MODELS,
  defaultResponseValidation,
} from "./config.types";
⋮----
/**
 * Configuration for retrieving relevant tools for the agent
 *
 * @param toolIds - Array of tool identifiers to include
 * @param allTools - Map of all available tools
 * @returns Record of tools mapped by their IDs
 * @throws {Error} When required tools are missing
 */
export function getToolsFromIds(
  toolIds: string[],
  allTools: ReadonlyMap<
    string,
    Tool<ZodTypeAny | undefined, ZodTypeAny | undefined>
  >
): Record<string, Tool<ZodTypeAny | undefined, ZodTypeAny | undefined>>
⋮----
/**
 * Configuration for the Copywriter Agent.
 *
 * @remarks
 * The Copywriter Agent focuses on creating marketing copy and content,
 * adapting to different brand voices, and optimizing messaging for various channels.
 *
 * @property {string[]} toolIds - The list of tool IDs required by the agent.
 */
⋮----
"exa-search", // Corrected ID
"tavily-search", // Corrected ID
⋮----
/**
 * Schema for structured copywriter agent responses
 */
⋮----
/**
 * Type for structured responses from the Copywriter agent
 */
export type CopywriterResponse = z.infer<typeof copywriterResponseSchema>;
⋮----
/**
 * Type for the Copywriter Agent configuration
 */
export type CopywriterAgentConfig = typeof copywriterAgentConfig;
````

## File: src/mastra/agents/config/debugger.config.ts
````typescript
/**
 * Debugger Agent Configuration
 *
 * This module defines the configuration for the Debugger Agent,
 * which specializes in identifying and fixing code issues and bugs.
 */
⋮----
import { z, type ZodTypeAny } from "zod";
import type { Tool } from "@mastra/core/tools";
import {
  BaseAgentConfig,
  DEFAULT_MODELS,
  defaultResponseValidation,
} from "./config.types";
⋮----
/**
 * Configuration for retrieving relevant tools for the agent
 *
 * @param toolIds - Array of tool identifiers to include
 * @param allTools - Map of all available tools
 * @returns Record of tools mapped by their IDs
 * @throws {Error} When required tools are missing
 */
export function getToolsFromIds(
  toolIds: string[],
  allTools: ReadonlyMap<
    string,
    Tool<ZodTypeAny | undefined, ZodTypeAny | undefined>
  >
): Record<string, Tool<ZodTypeAny | undefined, ZodTypeAny | undefined>>
⋮----
/**
 * Debugger Agent Configuration
 *
 * @remarks
 * The Debugger Agent focuses on troubleshooting, debugging, and resolving
 * technical issues in code. It analyzes error logs, traces execution paths,
 * and proposes fixes for bugs.
 */
⋮----
// "github", // Removed - clarify registration if needed
//"e2b",
⋮----
"analyze-content", // Added based on role
⋮----
/**
 * Schema for structured debugger agent responses
 */
⋮----
/**
 * Type for structured responses from the Debugger agent
 */
export type DebuggerResponse = z.infer<typeof debuggerResponseSchema>;
⋮----
/**
 * Type for the Debugger agent configuration
 */
export type DebuggerConfig = typeof debuggerConfig;
````

## File: src/mastra/agents/config/index.ts
````typescript
/**
 * Agent Configuration Module
 *
 * This module exports all agent configurations and configuration types.
 * Each agent has its own configuration file, and this module serves as
 * the central export point.
 */
⋮----
// Export core configuration types and utilities
⋮----
// Base configurations removed as part of refactoring
⋮----
// Export specific agent configurations without the common utility functions
// This prevents name conflicts from multiple exports of getToolsFromIds
import { analystAgentConfig, analystResponseSchema } from "./analyst.config";
import { architectConfig } from "./architect.config";
import {
  agenticAssistantConfig,
  agenticResponseSchema,
} from "./agentic.config";
import { coderAgentConfig, coderResponseSchema } from "./coder.config";
import {
  codeDocumenterConfig

} from "./codeDocumenter.config";
import {
  copywriterAgentConfig,
  copywriterResponseSchema,
} from "./copywriter.config";
import {
  dataManagerAgentConfig,
  dataManagerResponseSchema,
} from "./dataManager.config";
import { debuggerConfig, debuggerResponseSchema } from "./debugger.config";
import {
  marketResearchAgentConfig,
  marketResearchResponseSchema,
} from "./marketResearch.config";
import { researchAgentConfig, researchResponseSchema } from "./research.config";
import {
  rlTrainerAgentConfig,
  rlTrainerResponseSchema,
} from "./rlTrainer.config";
import { seoAgentConfig, seoResponseSchema } from "./seoAgent.config";
import {
  socialMediaAgentConfig,
  socialMediaResponseSchema,
} from "./socialMedia.config";
import { uiUxCoderConfig, uiUxCoderResponseSchema } from "./uiUxCoder.config";
import { writerAgentConfig, writerResponseSchema } from "./writer.config";
⋮----
// Re-export specific configurations
⋮----
// Agent configurations
⋮----
// All agent configurations are now exported here
````

## File: src/mastra/agents/config/marketResearch.config.ts
````typescript
/**
 * Market Research Agent Configuration
 *
 * This module defines the configuration for the Market Research Agent,
 * which specializes in analyzing markets, competitors, and user needs.
 */
⋮----
import { z, type ZodTypeAny } from "zod";
import type { Tool } from "@mastra/core/tools";
import {
  BaseAgentConfig,
  DEFAULT_MODELS,
  defaultResponseValidation,
} from "./config.types";
⋮----
/**
 * Configuration for retrieving relevant tools for the agent
 *
 * @param toolIds - Array of tool identifiers to include
 * @param allTools - Map of all available tools
 * @returns Record of tools mapped by their IDs
 * @throws {Error} When required tools are missing
 */
export function getToolsFromIds(
  toolIds: string[],
  allTools: ReadonlyMap<
    string,
    Tool<ZodTypeAny | undefined, ZodTypeAny | undefined>
  >
): Record<string, Tool<ZodTypeAny | undefined, ZodTypeAny | undefined>>
⋮----
/**
 * Market Research Agent Configuration
 *
 * @remarks
 * The Market Research Agent focuses on gathering and analyzing market data,
 * competitive intelligence, and user feedback to inform product and marketing strategies.
 */
⋮----
"exa-search", // Corrected ID
"google-search", // Corrected ID
"tavily-search", // Corrected ID
"brave-search", // Correct ID for Exa search
⋮----
"calculate-reward", // For analyzing metrics
⋮----
/**
 * Schema for structured market research agent responses
 */
⋮----
/**
 * Type for structured responses from the Market Research agent
 */
export type MarketResearchResponse = z.infer<
  typeof marketResearchResponseSchema
>;
⋮----
/**
 * Type for the Market Research agent configuration
 */
export type MarketResearchAgentConfig = typeof marketResearchAgentConfig;
````

## File: src/mastra/agents/config/seoAgent.config.ts
````typescript
/**
 * SEO Agent Configuration
 *
 * This module defines the configuration for the SEO Agent,
 * which specializes in search engine optimization strategies and implementation.
 */
⋮----
import { z, type ZodTypeAny } from "zod";
import type { Tool } from "@mastra/core/tools";
import {
  BaseAgentConfig,
  DEFAULT_MODELS,
  defaultResponseValidation,
} from "./config.types";
⋮----
/**
 * Configuration for retrieving relevant tools for the agent
 *
 * @param toolIds - Array of tool identifiers to include
 * @param allTools - Map of all available tools
 * @returns Record of tools mapped by their IDs
 * @throws {Error} When required tools are missing
 */
export function getToolsFromIds(
  toolIds: string[],
  allTools: ReadonlyMap<
    string,
    Tool<ZodTypeAny | undefined, ZodTypeAny | undefined>
  >
): Record<string, Tool<ZodTypeAny | undefined, ZodTypeAny | undefined>>
⋮----
/**
 * SEO Agent Configuration
 *
 * @remarks
 * The SEO Agent focuses on optimizing content for search engines,
 * analyzing keywords, and improving website visibility and rankings.
 */
⋮----
"exa-search", // Corrected ID
"google-search", // Corrected ID
"tavily-search", // Corrected ID
"brave-search", // Corrected ID
⋮----
/**
 * Schema for structured SEO agent responses
 */
⋮----
/**
 * Type for structured responses from the SEO agent
 */
export type SeoResponse = z.infer<typeof seoResponseSchema>;
⋮----
/**
 * Type for the SEO Agent configuration
 */
export type SeoAgentConfig = typeof seoAgentConfig;
````

## File: src/mastra/agents/config/socialMedia.config.ts
````typescript
/**
 * Social Media Agent Configuration
 *
 * This module defines the configuration for the Social Media Agent,
 * which specializes in creating and managing social media content and campaigns.
 */
⋮----
import { z, type ZodTypeAny } from "zod";
import type { Tool } from "@mastra/core/tools";
import {
  BaseAgentConfig,
  DEFAULT_MODELS,
  defaultResponseValidation,
} from "./config.types";
⋮----
/**
 * Configuration for retrieving relevant tools for the agent
 *
 * @param toolIds - Array of tool identifiers to include
 * @param allTools - Map of all available tools
 * @returns Record of tools mapped by their IDs
 * @throws {Error} When required tools are missing
 */
export function getToolsFromIds(
  toolIds: string[],
  allTools: ReadonlyMap<
    string,
    Tool<ZodTypeAny | undefined, ZodTypeAny | undefined>
  >
): Record<string, Tool<ZodTypeAny | undefined, ZodTypeAny | undefined>>
⋮----
/**
 * Social Media Agent Configuration
 *
 * @remarks
 * The Social Media Agent focuses on creating engaging social media content,
 * planning campaigns, and analyzing social engagement metrics to optimize reach.
 */
⋮----
"google-search", // Corrected ID
"tavily-search", // Corrected ID
"brave-search", // Corrected ID
⋮----
"calculate-reward", // For analyzing engagement metrics
⋮----
/**
 * Schema for structured social media agent responses
 */
⋮----
/**
 * Type for structured responses from the Social Media agent
 */
export type SocialMediaResponse = z.infer<typeof socialMediaResponseSchema>;
⋮----
/**
 * Type for the Social Media Agent configuration
 */
export type SocialMediaAgentConfig = typeof socialMediaAgentConfig;
````

## File: src/mastra/agents/config/uiUxCoder.config.ts
````typescript
/**
 * UI/UX Coder Agent Configuration
 *
 * This module defines the configuration for the UI/UX Coder Agent,
 * which specializes in frontend development and user experience implementation.
 */
⋮----
import { z, type ZodTypeAny } from "zod";
import type { Tool } from "@mastra/core/tools";
import {
  BaseAgentConfig,
  DEFAULT_MODELS,
  defaultResponseValidation,
} from "./config.types";
⋮----
/**
 * Configuration for retrieving relevant tools for the agent
 *
 * @param toolIds - Array of tool identifiers to include
 * @param allTools - Map of all available tools
 * @returns Record of tools mapped by their IDs
 * @throws {Error} When required tools are missing
 */
export function getToolsFromIds(
  toolIds: string[],
  allTools: ReadonlyMap<
    string,
    Tool<ZodTypeAny | undefined, ZodTypeAny | undefined>
  >
): Record<string, Tool<ZodTypeAny | undefined, ZodTypeAny | undefined>>
⋮----
/**
 * UI/UX Coder Agent Configuration
 *
 * @remarks
 * The UI/UX Coder Agent focuses on implementing user interfaces and user experience designs.
 * It specializes in frontend technologies, responsive design, and creating intuitive user interactions.
 */
⋮----
//"github",
//"e2b", // For previewing UI components
⋮----
/**
 * Schema for structured UI/UX coder agent responses
 */
⋮----
/**
 * Type for structured responses from the UI/UX Coder agent
 */
export type UiUxCoderResponse = z.infer<typeof uiUxCoderResponseSchema>;
⋮----
/**
 * Type for the UI/UX Coder Agent configuration
 */
export type UIUXCoderConfig = typeof uiUxCoderConfig;
````

## File: src/mastra/agents/config/writer.config.ts
````typescript
/**
 * Writer Agent Configuration
 *
 * This module defines the specific configuration for the Writer Agent,
 * which specializes in creating clear, engaging, and well-structured
 * documentation from complex information.
 */
⋮----
import { z, type ZodTypeAny } from "zod";
import type { Tool } from "@mastra/core/tools";
import {
  BaseAgentConfig,
  DEFAULT_MODELS,
  defaultResponseValidation,
} from "./config.types";
⋮----
/**
 * Configuration for retrieving relevant tools for the agent
 *
 * @param toolIds - Array of tool identifiers to include
 * @param allTools - Map of all available tools
 * @returns Record of tools mapped by their IDs
 * @throws {Error} When required tools are missing
 */
export function getToolsFromIds(
  toolIds: string[],
  allTools: ReadonlyMap<
    string,
    Tool<ZodTypeAny | undefined, ZodTypeAny | undefined>
  >
): Record<string, Tool<ZodTypeAny | undefined, ZodTypeAny | undefined>>
⋮----
/**
 * Configuration for the Writer Agent
 *
 * @remarks
 * The Writer Agent focuses on transforming complex information into accessible content,
 * adapting tone and style for different audiences, and maintaining consistency across documents.
 */
⋮----
/**
 * Schema for structured writer agent responses
 */
⋮----
/**
 * Type for structured responses from the Writer agent
 */
export type WriterResponse = z.infer<typeof writerResponseSchema>;
⋮----
/**
 * Type for the Writer Agent configuration
 */
export type WriterAgentConfig = typeof writerAgentConfig;
````

## File: src/mastra/agents/writer.agent.ts
````typescript
/**
 * Writer Agent Implementation
 *
 * This agent is specialized in creating clear, engaging, and well-structured
 * documentation from complex information.
 */
⋮----
import { createAgentFromConfig } from "./base.agent";
import { writerAgentConfig as writerConfig } from "./config";
import { sharedMemory } from "../database";
import { createLogger } from "@mastra/core/logger";
⋮----
/**
 * Writer Agent with content formatting capabilities
 *
 * @remarks
 * This agent can transform complex information into accessible content,
 * adapt tone and style for different audiences, and maintain consistency
 * across documents.
 */
⋮----
memory: sharedMemory, // Following RULE-MemoryInjection
````

## File: src/mastra/index.ts
````typescript
import { Mastra } from "@mastra/core";
import { createLogger } from "@mastra/core/logger";
import {
  researchAgent,
  analystAgent,
  writerAgent,
  rlTrainerAgent,
  dataManagerAgent,
} from "./agents";
import { ragWorkflow } from "./workflows";
import {
  deanInsightsNetwork,
  dataFlowNetwork,
  contentCreationNetwork,
  networks,
} from "./workflows/Networks/agentNetwork";
import { sharedMemory as memory } from "./database";
import {
  collectFeedbackTool,
  analyzeFeedbackTool,
  applyRLInsightsTool,
} from "./tools/rlFeedback";
import {
  calculateRewardTool,
  defineRewardFunctionTool,
  optimizePolicyTool,
} from "./tools/rlReward";
⋮----
// Re-export the RL tools for easier access
⋮----
// Re-export agent networks for easier access
⋮----
// Create and export the Mastra instance
⋮----
// Memory is now injected per agent via createAgentFromConfig instead of globally
// This follows RULE-MemoryInjection from best practices
⋮----
// Track request timing for RL metrics
````

## File: src/mastra/agents/agentic.agent.ts
````typescript
/**
 * Agentic-style Agent Implementation
 *
 * This module implements an advanced agent using Mastra's core functionality,
 * combining multiple tools for enhanced capabilities.
 */
⋮----
import { createLogger } from "@mastra/core/logger";
import { sharedMemory } from "../database";
import { createAgentFromConfig } from "./base.agent";
import { agenticAssistantConfig, agenticResponseSchema } from "./config";
⋮----
// Initialize logger for this module
⋮----
/**
 * Agentic-style Agent with data analysis capabilities
 *
 * @remarks
 * This agent is agentic in nature, capable of analyzing information,
 * identifying trends and patterns, and extracting meaningful insights from data sources.
 * It can also generate structured responses based on the provided schema.
 * The agent is designed to be flexible and adaptable, allowing for various use cases.
 * It also supports integration with external APIs for enhanced functionality.
 */
⋮----
memory: sharedMemory, // Following RULE-MemoryInjection
⋮----
export type AgenticAgent = typeof agenticAssistant;
⋮----
/**
 * Example usage:
 *
 * ```typescript
 * import { agenticAssistant, getStructuredResponse } from "./agents/agentic.agent";
 *
 * // Simple text response
 * const response = await agenticAssistant.generate("What's the weather like today?");
 * console.log(response.text);
 *
 * // Structured response with schema validation
 * const structuredResponse = await getStructuredResponse(
 *   "Analyze the current trends in renewable energy"
 * );
 * console.log(structuredResponse.answer);
 * console.log(structuredResponse.sources);
 * ```
 */
````

## File: src/mastra/agents/analyst.agent.ts
````typescript
/**
 * Analyst Agent Implementation
 *
 * This agent is specialized in interpreting data, identifying patterns,
 * and extracting meaningful insights from information.
 */
⋮----
import { createAgentFromConfig } from "./base.agent";
import { analystAgentConfig } from "./config";
import { sharedMemory } from "../database";
import { createLogger } from "@mastra/core/logger";
⋮----
/**
 * Analyst Agent with data analysis capabilities
 *
 * @remarks
 * This agent can analyze information, identify trends and patterns,
 * and extract meaningful insights from data sources.
 */
⋮----
memory: sharedMemory, // Following RULE-MemoryInjection
⋮----
export type AnalystAgent = typeof analystAgent;
````

## File: src/mastra/agents/config/analyst.config.ts
````typescript
/**
 * Analyst Agent Configuration
 *
 * This module defines the specific configuration for the Analyst Agent,
 * which specializes in interpreting data, identifying patterns,
 * and extracting meaningful insights.
 */
⋮----
import { z, type ZodTypeAny } from "zod";
import type { Tool } from "@mastra/core/tools";
import {
  BaseAgentConfig,
  DEFAULT_MODELS,
  defaultResponseValidation,
} from "./config.types";
⋮----
/**
 * Configuration for retrieving relevant tools for the agent
 *
 * @param toolIds - Array of tool identifiers to include
 * @param allTools - Map of all available tools
 * @returns Record of tools mapped by their IDs
 * @throws {Error} When required tools are missing
 */
export function getToolsFromIds(
  toolIds: string[],
  allTools: ReadonlyMap<
    string,
    Tool<ZodTypeAny | undefined, ZodTypeAny | undefined>
  >
): Record<string, Tool<ZodTypeAny | undefined, ZodTypeAny | undefined>>
⋮----
/**
 * Configuration for the Analyst Agent
 *
 * @remarks
 * The Analyst Agent focuses on analyzing information, identifying trends and patterns,
 * and extracting meaningful insights from various data sources.
 */
⋮----
"filtered-vector-query", // Corrected ID
⋮----
"analyze-content", // Added based on role
⋮----
/**
 * Schema for structured analyst responses
 */
⋮----
/**
 * Type for structured responses from the Analyst agent
 */
export type AnalystResponse = z.infer<typeof analystResponseSchema>;
⋮----
export type AnalystAgentConfig = typeof analystAgentConfig;
````

## File: src/mastra/agents/config/dataManager.config.ts
````typescript
/**
 * Data Manager Agent Configuration
 *
 * This module defines the specific configuration for the Data Manager Agent,
 * which specializes in managing data operations, file organization,
 * storage, and retrieval of information.
 */
⋮----
import { z, type ZodTypeAny } from "zod";
import type { Tool } from "@mastra/core/tools";
import {
  BaseAgentConfig,
  DEFAULT_MODELS,
  defaultResponseValidation,
} from "./config.types";
⋮----
/**
 * Configuration for retrieving relevant tools for the agent
 *
 * @param toolIds - Array of tool identifiers to include
 * @param allTools - Map of all available tools
 * @returns Record of tools mapped by their IDs
 * @throws {Error} When required tools are missing
 */
export function getToolsFromIds(
  toolIds: string[],
  allTools: ReadonlyMap<
    string,
    Tool<ZodTypeAny | undefined, ZodTypeAny | undefined>
  >
): Record<string, Tool<ZodTypeAny | undefined, ZodTypeAny | undefined>>
⋮----
/**
 * Configuration for the Data Manager Agent
 *
 * @remarks
 * The Data Manager Agent focuses on organizing, storing, retrieving, and managing
 * data assets across the system, including file operations and vector database management.
 */
⋮----
"filtered-vector-query", // Corrected ID
⋮----
"graph-rag", // Alias exists
⋮----
/**
 * Schema for structured data manager agent responses
 */
⋮----
/**
 * Type for structured responses from the Data Manager agent
 */
export type DataManagerResponse = z.infer<typeof dataManagerResponseSchema>;
⋮----
/**
 * Type for the Data Manager Agent configuration
 */
export type DataManagerAgentConfig = typeof dataManagerAgentConfig;
````

## File: src/mastra/agents/config/rlTrainer.config.ts
````typescript
/**
 * RL Trainer Agent Configuration
 *
 * This module defines the specific configuration for the RL Trainer Agent,
 * which specializes in reinforcement learning, collecting and analyzing
 * feedback, and optimizing agent behaviors.
 *
 * @module rlTrainer.config
 */
⋮----
import { z } from "zod";
import { Tool } from "@mastra/core/tools";
import {
  BaseAgentConfig,
  DEFAULT_MODELS,
  defaultResponseValidation,
} from "./config.types";
⋮----
/**
 * Configuration for retrieving relevant tools for the agent
 *
 * @param toolIds - Array of tool identifiers to include
 * @param allTools - Map of all available tools
 * @returns Record of tools mapped by their IDs
 * @throws {Error} When required tools are missing
 */
export function getToolsFromIds(
  toolIds: string[],
  allTools: ReadonlyMap<
    string,
    Tool<z.ZodTypeAny | undefined, z.ZodTypeAny | undefined>
  >
): Record<string, Tool<z.ZodTypeAny | undefined, z.ZodTypeAny | undefined>>
⋮----
/**
 * Configuration for the RL Trainer Agent
 *
 * @remarks
 * The RL Trainer Agent focuses on collecting user feedback, analyzing agent performance,
 * and implementing reinforcement learning techniques to improve agent behaviors.
 */
⋮----
/**
 * Schema for structured RL Trainer agent responses
 */
⋮----
/**
 * Type for structured responses from the RL Trainer agent
 */
export type RLTrainerResponse = z.infer<typeof rlTrainerResponseSchema>;
⋮----
/**
 * Type for the RL Trainer Agent configuration
 */
export type RLTrainerAgentConfig = typeof rlTrainerAgentConfig;
````

## File: src/mastra/agents/config/research.config.ts
````typescript
/**
 * Research Agent Configuration
 *
 * This module defines the configuration for the Research Agent, which specializes in
 * gathering, synthesizing, and analyzing information from various sources.
 */
⋮----
import { z, type ZodTypeAny } from "zod";
import type { Tool } from "@mastra/core/tools";
import {
  BaseAgentConfig,
  DEFAULT_MODELS,
  defaultResponseValidation,
} from "./config.types";
⋮----
/**
 * Configuration for retrieving relevant tools for the agent
 *
 * @param toolIds - Array of tool identifiers to include
 * @param allTools - Map of all available tools
 * @returns Record of tools mapped by their IDs
 * @throws {Error} When required tools are missing
 */
export function getToolsFromIds(
  toolIds: string[],
  allTools: ReadonlyMap<
    string,
    Tool<ZodTypeAny | undefined, ZodTypeAny | undefined>
  >
): Record<string, Tool<ZodTypeAny | undefined, ZodTypeAny | undefined>>
⋮----
/**
 * Configuration for the Research Agent.
 *
 * @remarks
 * The Research Agent focuses on information gathering and synthesis
 * using web searches, document analysis, and file operations.
 *
 * @property {string[]} toolIds - The list of tool IDs required by the agent.
 */
⋮----
"read-file", // Corrected ID
"write-file", // Corrected ID
"exa-search", // Specific search tool
"google-search", // Specific search tool
"tavily-search", // Specific search tool
"brave-search", // Specific search tool
"vector-query", // Specific vector tool
"google-vector-query", // Specific vector tool
"filtered-vector-query", // Specific vector tool
"search-documents", // Specific document tool
"memory-query", // Specific memory tool
⋮----
/**
 * Schema for structured research agent responses
 */
⋮----
/**
 * Type for structured responses from the Research agent
 */
export type ResearchResponse = z.infer<typeof researchResponseSchema>;
⋮----
/**
 * Type for the Research Agent configuration
 */
export type ResearchAgentConfig = typeof researchAgentConfig;
````

## File: src/mastra/workflows/index.ts
````typescript
import { Agent } from "@mastra/core/agent";
import { Step, Workflow } from "@mastra/core/workflows";
import { z } from "zod";
import { researchAgent, analystAgent, writerAgent } from "../agents";
import { sharedMemory as memory } from "../database";
import { PineconeStore } from "@langchain/pinecone";
import { GoogleGenerativeAIEmbeddings } from "@langchain/google-genai";
import { Pinecone } from "@pinecone-database/pinecone";
import { google } from "@ai-sdk/google";
import { generateText } from "ai";
⋮----
// Create a research step that gathers relevant information
⋮----
// Use the research agent to gather information
⋮----
// Return the research findings
⋮----
// Create an analysis step that processes the research findings
⋮----
// Use the analyst agent to analyze the findings
⋮----
// Return the analysis
⋮----
// Create a documentation step that creates a final report
⋮----
// Use the writer agent to create documentation
⋮----
// Store the final document in Pinecone for future retrieval
⋮----
// Initialize the Pinecone client
⋮----
// Get the index from the client
⋮----
// Return the final document
⋮----
// RL Feedback Collection Step (for reinforcement learning)
⋮----
// For simulation purposes, we'll use the AI SDK to evaluate the document
// Using mastra parameter for logging and tracing if available
⋮----
// Using the ai package's generateText function with google model
⋮----
// The result structure from generateText() is different
⋮----
// Extract JSON from the response
⋮----
// Default feedback if parsing fails
⋮----
// Store feedback in memory for reinforcement learning
⋮----
// Create a unique thread for storing this feedback entry
⋮----
// Store feedback as metadata on a new thread
⋮----
// Create the complete RAG workflow
⋮----
// Commit the workflow
⋮----
/**
 * Workflows Index
 *
 * This file exports all workflows and agent networks available in the DeanmachinesAI system.
 * Workflows provide predefined execution paths, while AgentNetworks use LLM-based routing
 * for dynamic agent collaboration.
 */
⋮----
// Export all available workflows
⋮----
// Export agent networks
⋮----
// TODO: Add and export additional workflow definitions here as they are developed
// export * from "./researchWorkflow";
````

## File: src/mastra/agents/index.ts
````typescript
/**
 * Agents Module
 *
 * This module exports all agent implementations from their individual files.
 * Each agent is specialized for a particular role in the system and is configured
 * with specific tools, memory settings, and instructions.
 */
⋮----
// Import agent instances from their modular files
import { researchAgent } from "./research.agent";
import { analystAgent } from "./analyst.agent";
import { writerAgent } from "./writer.agent";
import { rlTrainerAgent } from "./rlTrainer.agent";
import { dataManagerAgent } from "./dataManager.agent";
import { agenticAssistant } from "./agentic.agent";
import { coderAgent } from "./coder.agent";
import { copywriterAgent } from "./copywriter.agent";
⋮----
// Import coding team agents
import { architectAgent } from "./architect.agent";
import { debuggerAgent } from "./debugger.agent";
import { uiUxCoderAgent } from "./uiUxCoder.agent";
import { codeDocumenterAgent } from "./codeDocumenter.agent";
⋮----
// Import marketing team agents
import { marketResearchAgent } from "./marketResearch.agent";
import { socialMediaAgent } from "./socialMedia.agent";
import { seoAgent } from "./seoAgent.agent";
// Export individual agents
⋮----
// Core agents
⋮----
// Coding team agents
⋮----
// Marketing team agents
⋮----
// Define the agents object
⋮----
// Core agents
⋮----
rlTrainerAgent, // RL Trainer agent included
dataManagerAgent, // Data Manager agent included
⋮----
// Coding team agents
⋮----
// Marketing team agents
⋮----
// Export agents object for Mastra configuration
⋮----
// Export type for OpenAPI/Swagger documentation
export type AgentIds = keyof typeof agents;
````

## File: src/mastra/tools/index.ts
````typescript
/**
 * Tool Registry and Management
 *
 * This module serves as the central registry for all available tools,
 * handling their initialization, configuration, and export. It assembles
 * core, optional, additional, and extra tools into a lookup map so that agents
 * can easily find and use them.
 *
 * @module Tools
 */
⋮----
// === Standard library imports ===
import { env } from "process";
⋮----
// === Third-party imports ===
import { z } from "zod";
import { Tool } from "@mastra/core/tools";
import { createLogger } from "@mastra/core/logger";
⋮----
// === Internal tool imports ===
import {
  vectorQueryTool,
  googleVectorQueryTool,
  filteredQueryTool,
} from "./vectorquerytool";
import { createBraveSearchTool } from "./brave-search";
import { createGoogleSearchTool } from "./google-search";
import { createTavilySearchTool } from "./tavily";
import { exaSearchTool } from "./exasearch";
import { readFileTool, writeToFileTool } from "./readwrite";
import {
  collectFeedbackTool,
  analyzeFeedbackTool,
  applyRLInsightsTool,
} from "./rlFeedback";
import {
  calculateRewardTool,
  defineRewardFunctionTool,
  optimizePolicyTool,
} from "./rlReward";
import { memoryQueryTool } from "./memoryQueryTool";
⋮----
// --- Import additional tools from new modules ---
import { analyzeContentTool, formatContentTool } from "./contentTools";
import { searchDocumentsTool, embedDocumentTool } from "./document-tools";
⋮----
// --- Import extra modules that return or represent tool instances ---
import { GitHubClient } from "./github";
import { GraphNode } from "./graphRag";
import { createCalculatorTool } from "./calculator";
import { createLlamaIndexTools } from "./llamaindex";
import { McpTools } from "./mcptools";
import { arxiv } from "./arxiv";
import { WikipediaClient } from "./wikibase";
import { createAISDKTools } from "./ai-sdk";
import { e2b } from "./e2b";
// Import GraphRag tools so that they are read and fully functional.
import { createGraphRagTool, graphRagQueryTool } from "./graphRag";
import { llmChainTool, aiSdkPromptTool } from "./llmchain";
⋮----
// === Export all tool modules ===
⋮----
// === Configure Logger ===
⋮----
// === Environment Configuration ===
⋮----
/**
 * Schema for environment variables used to initialize tools.
 */
⋮----
// API keys for extra tools
⋮----
/**
 * Type alias for the validated environment configuration.
 */
export type EnvConfig = z.infer<typeof envSchema>;
⋮----
/**
 * Validates the environment configuration.
 *
 * @returns {EnvConfig} The validated environment configuration.
 * @throws {Error} When validation fails.
 */
function validateConfig(): EnvConfig
⋮----
// === Initialize Environment Configuration ===
⋮----
// === Search Tools Initialization ===
⋮----
/**
 * Record type for search tools.
 */
interface SearchToolRecord {
  [key: string]: Tool<z.ZodTypeAny, z.ZodTypeAny> | undefined;
}
⋮----
/**
 * Initializes search tools based on available API keys.
 */
⋮----
// === Core Tools Initialization ===
⋮----
/**
 * Core tools that are always available.
 */
⋮----
// === Additional Tools from contentTools and document-tools ===
⋮----
// === Extra Tools Initialization ===
/**
 * Extra tools aggregated from modules that expose tool instances.
 * NOTE: Some imports (like GraphNode, CalculatorConfig, WikipediaClient) are types or configurations,
 * so only tool instances are added to the tools map.
 */
⋮----
// Instantiate GitHub client using the provided API key.
⋮----
// Instantiate (or use) the E2B tool if it is already an instance.
⋮----
// Create and add LlamaIndex tools.
⋮----
// Add McpTools if provided as an array.
⋮----
// Include 'arxiv' tool if it is a valid tool instance.
⋮----
// Create and add AISDK tools.
⋮----
// Instantiate Wikipedia client.
⋮----
// Instantiate Calculator tool.
⋮----
// Add GraphRag tools to the extra tools array.
⋮----
// Create an alias tool for "graph-rag" required by data-manager-agent.
// This alias uses the properties of createGraphRagTool but overrides the id.
⋮----
// Add LLM chain tools for AI model interactions
⋮----
// === Filter Optional Search Tools ===
⋮----
// === Aggregate All Tools ===
⋮----
/**
 * Complete collection of all available tools (core + optional + additional + extra).
 */
⋮----
/**
 * Map for efficient lookup of tools by their ID.
 */
⋮----
/**
 * Grouped tools by category for easier access.
 */
⋮----
// === Log Initialization Results ===
⋮----
// For backward compatibility.
````

## File: package.json
````json
{
  "name": "deanmachinesai",
  "version": "1.0.1",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "mastra dev"
  },
  "keywords": [
    "mastra",
    "agentic",
    "deanmachines",
    "ai",
    "sdk",
    "openai",
    "google",
    "langchain",
    "mastra-sdk",
    "mastra-ai",
    "ai-sdk",
    "agentic-ai",
    "agentic-sdk",
    "ai-agents",
    "deanmachines-ai",
    "agents",
    "agent"
  ],
  "author": "Deanmachines",
  "license": "ISC",
  "description": "",
  "type": "module",
  "engines": {
    "node": ">=18.0.0"
  },
  "files": [
    "src",
    "dist",
    "README.md",
    "LICENSE"
  ],
  "dependencies": {
    "@agentic/ai-sdk": "^7.6.4",
    "@agentic/arxiv": "^7.6.4",
    "@agentic/brave-search": "^7.6.4",
    "@agentic/calculator": "^7.6.4",
    "@agentic/core": "^7.6.4",
    "@agentic/e2b": "^7.6.4",
    "@agentic/exa": "^7.6.4",
    "@agentic/firecrawl": "^7.6.4",
    "@agentic/genkit": "^7.6.4",
    "@agentic/google-custom-search": "^7.6.4",
    "@agentic/google-docs": "^7.6.4",
    "@agentic/google-drive": "^7.6.4",
    "@agentic/langchain": "^7.6.4",
    "@agentic/llamaindex": "^7.6.4",
    "@agentic/mastra": "^7.6.4",
    "@agentic/mcp": "^7.6.4",
    "@agentic/midjourney": "^7.6.4",
    "@agentic/notion": "^7.6.4",
    "@agentic/reddit": "^7.6.4",
    "@agentic/serper": "^7.6.4",
    "@agentic/social-data": "^7.6.4",
    "@agentic/stdlib": "^7.6.4",
    "@agentic/tavily": "^7.6.4",
    "@agentic/wikipedia": "^7.6.4",
    "@ai-sdk/anthropic": "^1.2.9",
    "@ai-sdk/google": "^1.2.10",
    "@ai-sdk/google-vertex": "^2.2.14",
    "@ai-sdk/openai": "^1.3.10",
    "@ai-sdk/provider": "^1.1.2",
    "@ai-sdk/provider-utils": "^2.2.6",
    "@e2b/code-interpreter": "^1.1.1",
    "@google-cloud/local-auth": "^3.0.1",
    "@google/generative-ai": "^0.1.3",
    "@hyperbrowser/sdk": "^0.43.0",
    "@langchain/anthropic": "^0.3.17",
    "@langchain/community": "^0.3.40",
    "@langchain/core": "^0.3.44",
    "@langchain/google-genai": "^0.2.3",
    "@langchain/openai": "^0.5.5",
    "@langchain/pinecone": "^0.2.0",
    "@mastra/client-js": "^0.1.16",
    "@mastra/core": "^0.8.2",
    "@mastra/deployer": "^0.2.8",
    "@mastra/evals": "^0.1.17",
    "@mastra/github": "^1.1.17",
    "@mastra/loggers": "^0.1.17",
    "@mastra/mcp": "^0.3.9",
    "@mastra/memory": "^0.2.9",
    "@mastra/pinecone": "^0.2.7",
    "@mastra/rag": "^0.1.17",
    "@mastra/upstash": "^0.2.4",
    "@mastra/vector-libsql": "^0.1.0-alpha.24",
    "@mastra/vector-pinecone": "^0.1.5",
    "@mastra/vector-upstash": "^0.1.5",
    "@mastra/voice-elevenlabs": "^0.1.12",
    "@mastra/voice-google": "^0.1.12",
    "@modelcontextprotocol/sdk": "^1.9.0",
    "@nanostores/react": "git+https://github.com/ai/react.git",
    "@opentelemetry/instrumentation": "^0.200.0",
    "@opentelemetry/semantic-conventions": "^1.32.0",
    "@pinecone-database/pinecone": "^5.1.1",
    "@upstash/vector": "^1.2.1",
    "ai": "^4.3.4",
    "commander": "^13.1.0",
    "dotenv": "^16.5.0",
    "exa-js": "^1.5.13",
    "fast-xml-parser": "^5.2.0",
    "fs-extra": "^11.3.0",
    "genkit": "^1.6.0",
    "google-auth-library": "^9.15.1",
    "googleapis": "^148.0.0",
    "husky": "^9.1.7",
    "inversify": "^7.5.0",
    "json": "^11.0.0",
    "ky": "^1.8.0",
    "langchain": "^0.3.21",
    "langfuse": "^3.37.1",
    "langsmith": "^0.3.15",
    "llamaindex": "^0.9.17",
    "lodash": "^4.17.21",
    "octokit": "^4.1.3",
    "p-throttle": "^6.2.0",
    "puppeteer-core": "^24.6.1",
    "ramda": "^0.30.1",
    "ts-node": "^10.9.2",
    "uuid": "^11.1.0",
    "winston": "^3.17.0",
    "zod": "^3.24.2"
  },
  "devDependencies": {
    "@types/node": "^22.14.0",
    "js-tiktoken": "^1.0.19",
    "mastra": "^0.4.8",
    "tsx": "^4.19.3",
    "typescript": "^5.8.3"
  },
  "pnpm": {
    "overrides": {
      "pathe": "^1.1.2"
    },
    "onlyBuiltDependencies": [
      "@swc/core",
      "canvas",
      "esbuild",
      "onnxruntime-node",
      "openai-zod-to-json-schema",
      "protobufjs",
      "sharp",
      "tree-sitter"
    ]
  }
}
````

## File: README.md
````markdown
# DeanmachinesAI

DeanmachinesAI is a state-of-the-art, Mastra AI‑powered platform that transforms research, analysis, and document processing through intelligent agent orchestration, dynamic networks, and robust, automated workflows. By combining advanced reinforcement learning, high-performance vector search capabilities, and complete observability, this platform is engineered for scalability, resilience, and continuous improvement.

---

## Key Technologies & Badges

[![TypeScript](https://img.shields.io/badge/TypeScript-5.x-blue?logo=typescript)](https://www.typescriptlang.org)
[![Node.js](https://img.shields.io/badge/Node.js-%3E=18.0.0-green?logo=node.js)](https://nodejs.org)
[![Mastra](https://img.shields.io/badge/Mastra-AI-ff69b4?logo=ant-design)](https://github.com/mastra-ai)
[![LangChain](https://img.shields.io/badge/LangChain-TS-blueviolet)](https://github.com/langchain-ai/langchainjs)
[![Pinecone](https://img.shields.io/badge/Pinecone-VectorDB-blue?logo=pinecone)](https://www.pinecone.io)
[![Redis](https://img.shields.io/badge/Redis-Cache-red?logo=redis)](https://redis.io)
[![GoogleAI](https://img.shields.io/badge/Google_AI-External%20API-blue?logo=google)](https://ai.google)
[![LibSQL](https://img.shields.io/badge/LibSQL-Turso-darkgreen)](https://turso.tech)
[![Next.js](https://img.shields.io/badge/Next.js-Frontend-black?logo=next.js)](https://nextjs.org)

---

## 📋 Project Overview

**DeanmachinesAI** integrates modern TypeScript practices with the Mastra framework to deliver an advanced platform with the following key features:

- **Intelligent Agent Orchestration:**
  Dynamic routing and coordination among an ecosystem of specialized agents:
  - **Research Agent:** Gathers and synthesizes data from diverse sources.
  - **Analyst Agent:** Interprets data to extract actionable insights.
  - **Writer Agent:** Generates high-quality documentation and reports.
  - **RL Trainer Agent:** Continuously improves system policies through reinforcement learning.
  - **Data Manager Agent:** Handles file operations and memory management.
  - **Builder Agent:** *(Upcoming)* Automatically builds and configures new agents to dynamically expand the system.

- **Robust Workflow Automation:**
  Seamless integration of reinforcement learning feedback, document processing pipelines, and high-performance vector search across distributed microservices enhances automation and minimizes human intervention.

- **Scalable, Resilient Architecture:**
  Utilizing dedicated services for:
  - Fast vector storage (via Pinecone)
  - Persistent memory storage (via Turso/LibSQL)
  - High-speed caching (via Redis)

- **Complete Observability:**
  End-to-end trace logging and real-time performance monitoring through LangSmith and LangFuse provide transparency, facilitate proactive error detection, and ensure security.

- **Future Frontend Integration:**
  Upcoming integration with a fully built Next.js frontend will provide dynamic dashboards, detailed metric visualizations, and interactive control over agent activities.

---

## 🏗️ Detailed System Architecture

### System Context

```mermaid
C4Context
    title DeanmachinesAI - System Context
    Person(user, "User", "An external user interfacing with the system via a Next.js based web dashboard")
    System(deanam, "DeanmachinesAI", "A Mastra AI–powered platform for research, analysis, and document processing")
    Rel(user, deanam, "Interacts via web interface", "HTTPS")
```

### Container Diagram

```mermaid
C4Container
    title DeanmachinesAI - Container Diagram

    Container(deanam, "DeanmachinesAI Backend", "Node.js / TypeScript", "Handles agent orchestration, tool integration, and API management")
    Container(nextjs, "Next.js Frontend", "Next.js", "Provides an interactive dashboard and real-time monitoring")
    ContainerDb(pinecone, "Pinecone DB", "Vector Database", "Stores vector embeddings and semantic indexes")
    ContainerDb(turso, "Turso (LibSQL)", "SQL Database", "Persistent memory storage for agent state and metadata")
    Container(redis, "Redis Cache", "Cache", "High-speed caching for performance")

    Rel(deanam, pinecone, "Stores embeddings", "HTTPS/REST")
    Rel(deanam, turso, "Persists agent memory", "SQL")
    Rel(deanam, redis, "Caches data", "Redis protocol")
    Rel(nextjs, deanam, "API calls for live data", "HTTPS")
```

---

## ⏱️ Planned Enhancements & Real Roadmap

### Current Achievements

- **Complete Tool Integration:**
  All core, search, document processing, reinforcement learning, and extra tool modules are fully integrated.
- **High-Performance Vector Search:**
  Multiple embedding strategies using Pinecone and js‑tiktoken have been successfully implemented.
- **Full Observability Setup:**
  End-to-end trace logging and performance monitoring are operational via LangSmith and LangFuse.
- **Robust Memory Infrastructure:**
  Turso and Redis are integrated for persistent memory and caching.
- **Initial Next.js API Integration:**
  Early groundwork for the Next.js frontend is complete, providing a foundation for interactive dashboards and real-time monitoring.

### Near-Term Roadmap (May–August 2025)

- **May 2025:**
  - **Next.js Dashboard Integration:**
    Finalize API endpoint expansion and integrate the Next.js dashboard for real-time metrics.
    *Milestone: Live updating dashboards showcasing agent statuses and trace metrics.*
- **June 2025:**
  - **Toolset Expansion & Agent Evolution:**
    Develop additional specialized tools and implement auto-configuration for new agents via the Builder Agent.
    *Milestone: New tools deployed and experimental agent-building feature available for internal testing.*
- **July 2025:**
  - **Reinforcement Learning Enhancements:**
    Introduce multi-objective RL frameworks and cross-agent transfer learning to boost decision making and responsiveness.
    *Milestone: RL modules report improved learning curves and reduced action optimization latency.*
- **August 2025:**
  - **System Optimization & Final Frontend Integration:**
    Optimize clustering, load balancing, and caching; finalize full Next.js frontend integration for production monitoring.
    *Milestone: Complete, production-ready frontend with full interactivity and real-time analytics.*

### Gantt Chart

```mermaid
gantt
    title DeanmachinesAI Development Roadmap
    dateFormat  YYYY-MM-DD
    excludes    weekends

    section Next.js Dashboard Integration
    Finalize API Endpoints       :done,    api,    2025-05-01, 2025-05-05
    Integrate Next.js Dashboard  :active,  nxjs,   2025-05-06, 2025-05-31

    section Toolset Expansion & Agent Evolution
    Develop Additional Tools     :active,  tools,  2025-06-01, 2025-06-15
    Implement Builder Agent      :pending, ab,     2025-06-16, 2025-06-30

    section Reinforcement Learning Enhancements
    Multi-Objective RL Framework :pending,  rlmo,   2025-07-01, 2025-07-15
    Cross-Agent Transfer Learning:pending,  catl,   2025-07-16, 2025-07-31

    section System Optimization & Final Frontend Integration
    Optimize Clustering & Load Balancing :pending, opt, 2025-08-01, 2025-08-15
    Finalize Next.js Frontend Integration   :pending, fin, 2025-08-16, 2025-08-31
```

---

## 📖 Developer Guide & Onboarding

### Prerequisites

- **Node.js (>=18.0.0)**
- **pnpm** (or your preferred package manager configured for ES modules)
- **Next.js** (for upcoming frontend development)

### Installation

Clone the repository and install dependencies:

```bash
git clone https://github.com/Deanmachines/deanmachinesai.git
cd deanmachinesai
pnpm install
```

### Running in Development Mode

Start the development server:

```bash
pnpm run dev
```

### Testing

Run the complete test suite:

```bash
pnpm test
```

### Deployment

Bundle and deploy the application with:

```bash
mastra build
```

Ensure that all required environment variables (see `.env.sample`) are properly configured and deploy using your chosen Node.js hosting provider.

### Documentation

For detailed developer guides, architecture documents, and integration tutorials, refer to the `/docs` directory.

---

## 📚 Additional Resources

- **[Open API Documentation](http://localhost:4111/openapi.json)**
- **[Swagger UI](http://localhost:4111/swagger-ui)**
- **[Project Playground](http://localhost:4111/)**

For more technical details on agent orchestration, tool integrations, and system design, please consult our comprehensive documentation within the `/docs` folder.

---

## 📝 License

DeanmachinesAI is licensed under the ISC License. See the [LICENSE](LICENSE) file for further details.

---

## 📊 Change Log & Release Notes

### Version 1.0.0 (Current)

- Complete integration of all tool modules (core, search, RL, document processing, extra integrations).
- High-performance vector search via Pinecone & js‑tiktoken.
- Full observability with LangSmith and preliminary Next.js integration.

### Upcoming Releases

- **v1.1.0 (May 2025):**
  - Next.js dashboard integration with live performance monitoring.
  - Introduction of experimental agent-building features.
  - Expansion of specialized tools and API endpoint enhancements.
- **v1.2.0 (June–August 2025):**
  - Finalization of Next.js frontend with full production readiness.
  - Enhanced reinforcement learning capabilities and system optimizations.
  - Advanced external data integrations and comprehensive logging improvements.

---

*This README is continually maintained as part of our project’s continuous improvement initiative. For any questions, contributions, or feedback, please open an issue or submit a pull request on GitHub.*

```mermaid
graph TB
    User(("External User"))

    subgraph "Mastra AI System"
        subgraph "Agent Network Layer"
            DeanInsights["DeanInsights Network<br>AgentNetwork"]
            DataFlow["DataFlow Network<br>AgentNetwork"]
            ContentCreation["ContentCreation Network<br>AgentNetwork"]
            KnowledgeMoE["Knowledge Work MoE Network<br>AgentNetwork"]
        end

        subgraph "Core Agents"
            ResearchAgent["Research Agent<br>Gemini AI"]
            AnalystAgent["Analyst Agent<br>Gemini AI"]
            WriterAgent["Writer Agent<br>Gemini AI"]
            RLTrainerAgent["RL Trainer Agent<br>Gemini AI"]
            DataManagerAgent["Data Manager Agent<br>Gemini AI"]
        end

        subgraph "Database Layer"
            VectorStore["Vector Store<br>Pinecone"]
            Memory["Memory Store<br>LibSQL"]
            Cache["Cache Layer<br>Redis"]
        end

        subgraph "Services Layer"
            LangChain["LangChain Service<br>LangChain"]
            ExaSearch["ExaSearch Service<br>REST API"]
            LangFuse["LangFuse Service<br>Telemetry"]
            LangSmith["LangSmith Service<br>Monitoring"]
        end

        subgraph "Tools Layer"
            subgraph "Search Tools"
                BraveSearch["Brave Search<br>REST API"]
                GoogleSearch["Google Search<br>REST API"]
                TavilySearch["Tavily Search<br>REST API"]
            end

            subgraph "Vector Tools"
                VectorQuery["Vector Query Tool<br>Pinecone"]
                GoogleVectorQuery["Google Vector Query<br>Gemini"]
                FilteredQuery["Filtered Query<br>Custom"]
            end

            subgraph "File Tools"
                ReadFile["Read File Tool<br>Node.js"]
                WriteFile["Write File Tool<br>Node.js"]
            end

            subgraph "RL Tools"
                FeedbackTools["Feedback Tools<br>Custom"]
                RewardTools["Reward Tools<br>Custom"]
            end
        end
    end

    subgraph "External Services"
        GoogleAI["Google AI<br>Gemini"]
        PineconeDB["Pinecone DB<br>Vector Database"]
    end

    %% Relationships
    User -->|"Interacts with"| DeanInsights
    User -->|"Interacts with"| DataFlow
    User -->|"Interacts with"| ContentCreation
    User -->|"Interacts with"| KnowledgeMoE

    %% Network to Agent relationships
    DeanInsights -->|"Coordinates"| ResearchAgent
    DeanInsights -->|"Coordinates"| AnalystAgent
    DeanInsights -->|"Coordinates"| WriterAgent
    DataFlow -->|"Coordinates"| DataManagerAgent
    DataFlow -->|"Coordinates"| AnalystAgent
    ContentCreation -->|"Coordinates"| ResearchAgent
    ContentCreation -->|"Coordinates"| WriterAgent

    %% Agent to Service relationships
    ResearchAgent -->|"Uses"| LangChain
    AnalystAgent -->|"Uses"| LangChain
    WriterAgent -->|"Uses"| LangChain
    RLTrainerAgent -->|"Uses"| LangSmith
    DataManagerAgent -->|"Uses"| VectorStore

    %% Service to External Service relationships
    LangChain -->|"Calls"| GoogleAI
    VectorStore -->|"Stores in"| PineconeDB

    %% Tool relationships
    ResearchAgent -->|"Uses"| BraveSearch
    ResearchAgent -->|"Uses"| GoogleSearch
    ResearchAgent -->|"Uses"| VectorQuery
    DataManagerAgent -->|"Uses"| ReadFile
    DataManagerAgent -->|"Uses"| WriteFile
    RLTrainerAgent -->|"Uses"| FeedbackTools
    RLTrainerAgent -->|"Uses"| RewardTools

    %% Database relationships
    ResearchAgent -->|"Uses"| Memory
    AnalystAgent -->|"Uses"| Memory
    WriterAgent -->|"Uses"| Memory
    DataManagerAgent -->|"Uses"| VectorStore
```
````
